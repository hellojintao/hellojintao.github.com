<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go中netpoll的工作机制</title>
    <url>/posts/794f771b.html</url>
    <content><![CDATA[<h2 id="netpollGenericInit-初始化-poller"><a href="#netpollGenericInit-初始化-poller" class="headerlink" title="netpollGenericInit 初始化 poller"></a>netpollGenericInit 初始化 poller</h2><p>netpollGenericInit 保证 poller 被初始化，原子变量netpollInited保证其仅被初始化一次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollGenericInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.Load(&amp;netpollInited) == <span class="number">0</span> &#123;</span><br><span class="line">    lockInit(&amp;netpollInitLock, lockRankNetpollInit)</span><br><span class="line">    lock(&amp;netpollInitLock)</span><br><span class="line">    <span class="keyword">if</span> netpollInited == <span class="number">0</span> &#123;</span><br><span class="line">      netpollinit()</span><br><span class="line">      atomic.Store(&amp;netpollInited, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;netpollInitLock)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数只是一个壳，初始化逻辑封装在netpollinit函数中，依赖于平台具体的实现。linux下，init的逻辑是:</p>
<ol>
<li>通过epoll_create1系统调用创建 epoll fd</li>
<li>创建一对 read/write pipe。pipe的一个特性是向 write pipe写入数据，read pipe 就能收到同样的数据</li>
<li>通过epoll_ctl将 write pipe 对应的fd 加入到监听列表</li>
</ol>
<p>单独创建一对pipe后，runtime就能够按需中断epoll_wait，让netpoll函数立即返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">  <span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">    epfd = epollcreate(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, -epfd)</span><br><span class="line">      throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    closeonexec(epfd)</span><br><span class="line">  &#125;</span><br><span class="line">  r, w, errno := nonblockingPipe()</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;runtime: pipe failed with&quot;</span>, -errno)</span><br><span class="line">    throw(<span class="string">&quot;runtime: pipe failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ev := epollevent&#123;</span><br><span class="line">    events: _EPOLLIN,</span><br><span class="line">  &#125;</span><br><span class="line">  *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd</span><br><span class="line">  errno = epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, -errno)</span><br><span class="line">    throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  netpollBreakRd = <span class="type">uintptr</span>(r)</span><br><span class="line">  netpollBreakWr = <span class="type">uintptr</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll函数"><a href="#netpoll函数" class="headerlink" title="netpoll函数"></a>netpoll函数</h2><p>netpoll函数的功能是检查可用的网络连接，它的工作流程是(happy path)：</p>
<ol>
<li><p>创建size=128的epollevent数组, 以接收事件</p>
</li>
<li><p>调用epollwait等待事件: 依赖epoll_wait系统调用</p>
</li>
<li><p>遍历epoll events，对于每个event</p>
</li>
<li><ul>
<li>创建一个pollDesc对象</li>
<li>调用netpollready，找到对应的goroutine，并将其状态从pdWait修改为pdReady</li>
</ul>
</li>
<li><p>返回pdReady状态的 goroutine列表 (gList)</p>
</li>
</ol>
<p>struct pollDesc中包含两个信号量字段，可以表示四种状态:</p>
<ol>
<li><p>pdReady: io ready信号等待被接收，goroutine可以消费这个信号，逻辑上是把信号量改成nil</p>
</li>
<li><p>pdWait: goroutine已经准备好在该信号量上阻塞，但还没有阻塞；</p>
</li>
<li><ul>
<li>如果goroutine通过gopark阻塞，状态会变成G pointer</li>
<li>如果并发的io ready信号到达，状态会改成pdReady</li>
<li>如果并发的timeout/close信号到达，状态会被改成nil</li>
</ul>
</li>
<li><p>G pointer: goroutine被阻塞在信号量上，可以被下面两类事件唤醒:</p>
</li>
<li><ul>
<li>io ready信号到来时，状态被修改好pdReady</li>
<li>timeout/close信号到来时，状态被修改为nil</li>
</ul>
</li>
<li><p>nil: 不是上面三种状态</p>
</li>
</ol>
<p>对应一些辅助函数:</p>
<ul>
<li>netpollblock 函数将goroutine状态从 pdReady 转化成 pdWait，并gopark当前goroutine</li>
<li>netpollunblock 函数将goroutine状态从 pdWait 转换为 pdReady 或 nil</li>
</ul>
<p>netpoll函数的代码在runtime/netpoll_epoll.go中，部分代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> gList &#123;</span><br><span class="line">  <span class="comment">// epoll fd 为-1，说明不需要poll</span></span><br><span class="line">  <span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line">  <span class="comment">// ...省略一段代码</span></span><br><span class="line">  <span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">  n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n != -_EINTR &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: epollwait on fd&quot;</span>, epfd, <span class="string">&quot;failed with&quot;</span>, -n)</span><br><span class="line">      throw(<span class="string">&quot;runtime: netpoll failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If a timed sleep was interrupted, just return to</span></span><br><span class="line">    <span class="comment">// recalculate how long we should sleep now.</span></span><br><span class="line">    <span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> retry</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> toRun gList</span><br><span class="line">  <span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">    ev := &amp;events[i]</span><br><span class="line">    <span class="keyword">if</span> ev.events == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">      <span class="comment">// ... read pipe 有数据</span></span><br><span class="line">      <span class="comment">// 不需要唤醒任何goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line">    <span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">      mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">      mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">      pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">      pd.setEventErr(ev.events == _EPOLLERR)</span><br><span class="line">      <span class="comment">// 将goroutine置为 pdReady</span></span><br><span class="line">      <span class="comment">// 并添加到toRun *gList</span></span><br><span class="line">      netpollready(&amp;toRun, pd, mode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toRun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注: netpollready 函数借助于netpollunblock修改goroutine状态，并将其加到 io ready 的 goroutine list。</p>
<p>runtime在调用 netpoll 时，通常采用的是 nonblock 模式(delay=0), 只有在 findrunnable 的最后一个环节，会检查是否有单独的M(GMP中的M)进行net polling，如果没有，会block等待delay参数指定的时间。</p>
<h2 id="netpollBreak-函数"><a href="#netpollBreak-函数" class="headerlink" title="netpollBreak 函数"></a>netpollBreak 函数</h2><p>netpollBreak函数的功能比较简单，但实现比较有意思。它和netpoll函数通过变量netpollWakeSig进行交互，由于在不同的goroutine中，所以对于该变量的操作都是原则操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// netpollBreak interrupts an epollwait.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.Cas(&amp;netpollWakeSig, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> b <span class="type">byte</span></span><br><span class="line">      n := write(netpollBreakWr, unsafe.Pointer(&amp;b), <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> n == -_EINTR &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> n == -_EAGAIN &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: netpollBreak write failed with&quot;</span>, -n)</span><br><span class="line">      throw(<span class="string">&quot;runtime: netpollBreak write failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll-runtime-pollOpen-函数"><a href="#poll-runtime-pollOpen-函数" class="headerlink" title="poll_runtime_pollOpen 函数"></a>poll_runtime_pollOpen 函数</h2><p>poll_runtime_pollOpen 的逻辑分为三块:</p>
<ol>
<li>给 pollDesc 分配内存</li>
<li>初始化 pollDesc 对象</li>
<li>借助于 netpollopen 注册epoll监听(netpollopen在linux下是 epoll_ctl)</li>
<li>返回 pollDesc 对象</li>
</ol>
<p>poll_runtime_pollOpen函数的实现位于 runtime/netpoll.go 中, 主要逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> (*pollDesc, <span class="type">int</span>) &#123;</span><br><span class="line">  pd := pollcache.alloc()</span><br><span class="line">  lock(&amp;pd.lock)</span><br><span class="line">  wg := pd.wg.Load()</span><br><span class="line">  <span class="keyword">if</span> wg != <span class="number">0</span> &amp;&amp; wg != pdReady &#123;</span><br><span class="line">    throw(<span class="string">&quot;runtime: blocked write on free polldesc&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  rg := pd.rg.Load()</span><br><span class="line">  <span class="keyword">if</span> rg != <span class="number">0</span> &amp;&amp; rg != pdReady &#123;</span><br><span class="line">    throw(<span class="string">&quot;runtime: blocked read on free polldesc&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  pd.fd = fd</span><br><span class="line">  <span class="comment">// ... 省略部分初始化逻辑</span></span><br><span class="line">  unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">  errno := netpollopen(fd, pd)</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    pollcache.free(pd)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="type">int</span>(errno)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pd, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于net/netpoll_epoll.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> ev epollevent</span><br><span class="line">  ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">  *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">  <span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll-runtime-pollWait-函数"><a href="#poll-runtime-pollWait-函数" class="headerlink" title="poll_runtime_pollWait 函数"></a>poll_runtime_pollWait 函数</h2><p>poll_runtime_pollWait 函数只是对 netpollblock 函数的封装，增加了容错。值得注意的是，该函数不是runtime触发的，而是用户程序触发的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  errcode := netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">  <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">    <span class="keyword">return</span> errcode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// As for now only Solaris, illumos, and AIX use level-triggered IO.</span></span><br><span class="line">  <span class="keyword">if</span> GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;aix&quot;</span> &#123;</span><br><span class="line">    netpollarm(pd, mode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">    errcode = netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">    <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">      <span class="keyword">return</span> errcode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Can happen if timeout has fired and unblocked us,</span></span><br><span class="line">    <span class="comment">// but before we had a chance to run, timeout has been reset.</span></span><br><span class="line">    <span class="comment">// Pretend it has not happened and retry.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们看下用户程序如何触发 poll_runtime_xxx 系列的函数。首先，套接字分为两类：LISTEN套接字(Server套接字) 和 ESTABLISHED套接字(TCPConn)；</p>
<ul>
<li>LISTEN 套接字通过系统调用 socket/bind/listen 去生成；</li>
<li>ESTABLISHED 套接字通过系统调用 accept 去生成；</li>
</ul>
<h2 id="LISTEN套接字-Server套接字"><a href="#LISTEN套接字-Server套接字" class="headerlink" title="LISTEN套接字(Server套接字)"></a>LISTEN套接字(Server套接字)</h2><p>从http server的角度来看，LISTEN套接字注册epoll监听的链路如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> ListenAndServe() <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// net/dial.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="type">string</span>)</span></span> (Listener, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> lc ListenConfig</span><br><span class="line">  <span class="keyword">return</span> lc.Listen(context.Background(), network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/dial.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lc *ListenConfig)</span></span> Listen(ctx context.Context, network, address <span class="type">string</span>) (Listener, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/tcpsock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sysListener)</span></span> listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/ipsock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internetSocket</span><span class="params">(ctx context.Context, net <span class="type">string</span>, laddr, raddr sockaddr, sotype, proto <span class="type">int</span>, mode <span class="type">string</span>, ctrlFn <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>, syscall.RawConn)</span></span> <span class="type">error</span>) (fd *netFD, err <span class="type">error</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// net/sock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="type">string</span>, family, sotype, proto <span class="type">int</span>, ipv6only <span class="type">bool</span>, laddr, raddr sockaddr, ctrlFn <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>, syscall.RawConn)</span></span> <span class="type">error</span>) (fd *netFD, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/sock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> listenStream(laddr sockaddr, backlog <span class="type">int</span>, ctrlFn <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, <span class="type">string</span>, syscall.RawConn)</span></span> <span class="type">error</span>)</span><br><span class="line">  <span class="keyword">if</span> err = fd.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> init() <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// fd.pfd 类型是 poll.FD</span></span><br><span class="line">  <span class="keyword">return</span> fd.pfd.Init(fd.net, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Init(net <span class="type">string</span>, pollable <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// We don&#x27;t actually care about the various network types.</span></span><br><span class="line">  <span class="keyword">if</span> net == <span class="string">&quot;file&quot;</span> &#123;</span><br><span class="line">    fd.isFile = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> !pollable &#123;</span><br><span class="line">    fd.isBlocking = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  err := fd.pd.init(fd)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// If we could not initialize the runtime poller,</span></span><br><span class="line">    <span class="comment">// assume we are using blocking mode.</span></span><br><span class="line">    fd.isBlocking = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_poll_runtime.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">  serverInit.Do(runtime_pollServerInit)</span><br><span class="line">  ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">  &#125;</span><br><span class="line">  pd.runtimeCtx = ctx</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ESTABLISHED套接字-TCPConn"><a href="#ESTABLISHED套接字-TCPConn" class="headerlink" title="ESTABLISHED套接字(TCPConn)"></a>ESTABLISHED套接字(TCPConn)</h2><p>http server accept 新的tcp conn</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    rw, err := l.Accept()</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/tcpsock.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TCPListener)</span></span> Accept() (Conn, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *TCPListener)</span></span> accept() (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line">  fd, err := ln.fd.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/fd_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> accept() (netfd *netFD, err <span class="type">error</span>) &#123;</span><br><span class="line">  d, rsa, errcall, err := fd.pfd.Accept()</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  <span class="keyword">if</span> err = netfd.init(); err != <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Init(net <span class="type">string</span>, pollable <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_poll_runtime.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h2 id="关于-net-netFD-struct"><a href="#关于-net-netFD-struct" class="headerlink" title="关于 net.netFD struct"></a>关于 net.netFD struct</h2><p>netFD是对套接字(网络文件描述符)的封装。对于Server套接字而言，可以通过accept方法从Server套接字(LISTEN套接字)获取新的TCP连接(或ESTABLISHED套接字)。Linux的accept系统调用返回的ESTABLISHED套接字是一个int值，通过 newFD 和 init 函数将其封装为一个完整的 netFD结构，后面会被封装为一个net.TCPConn。</p>
<p>对于操作系统而言，LISTEN套接字和ESTABLISHED套接字都只是一个int类型的文件描述符，没有本质区别。系统调用accept和read都是从套接字读取数据，所以epoll里会放到一个batch里去监听。</p>
<p>这是 netFD 的定义和accept方法的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Network file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">  pfd poll.FD</span><br><span class="line"></span><br><span class="line">  <span class="comment">// immutable until Close</span></span><br><span class="line">  family      <span class="type">int</span></span><br><span class="line">  sotype      <span class="type">int</span></span><br><span class="line">  isConnected <span class="type">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">  net         <span class="type">string</span></span><br><span class="line">  laddr       Addr</span><br><span class="line">  raddr       Addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> accept() (netfd *netFD, err <span class="type">error</span>) &#123;</span><br><span class="line">  d, rsa, errcall, err := fd.pfd.Accept()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> errcall != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      err = wrapSyscallError(errcall, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    poll.CloseFunc(d)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err = netfd.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    netfd.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  lsa, _ := syscall.Getsockname(netfd.pfd.Sysfd)</span><br><span class="line">  netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))</span><br><span class="line">  <span class="keyword">return</span> netfd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>net.netFD 依赖 poll.FD 实现poll功能。区别正如名字所展示，net.netFD是封装了网络相关的功能，而 poll.FD是更为通用的FD，封装了文件描述符上能进行的操作。其定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FD is a file descriptor. The net and os packages use this type as a</span></span><br><span class="line"><span class="comment">// field of a larger type representing a network connection or OS file.</span></span><br><span class="line"><span class="keyword">type</span> FD <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// Lock sysfd and serialize access to Read and Write methods.</span></span><br><span class="line">  fdmu fdMutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">// System file descriptor. Immutable until Close.</span></span><br><span class="line">  Sysfd <span class="type">int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// I/O poller.</span></span><br><span class="line">  pd pollDesc</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Writev cache.</span></span><br><span class="line">  iovecs *[]syscall.Iovec</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Semaphore signaled when file is closed.</span></span><br><span class="line">  csema <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Non-zero if this file has been set to blocking mode.</span></span><br><span class="line">  isBlocking <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether this is a streaming descriptor, as opposed to a</span></span><br><span class="line">  <span class="comment">// packet-based descriptor like a UDP socket. Immutable.</span></span><br><span class="line">  IsStream <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether a zero byte read indicates EOF. This is false for a</span></span><br><span class="line">  <span class="comment">// message based socket connection.</span></span><br><span class="line">  ZeroReadIsEOF <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether this is a file rather than a network socket.</span></span><br><span class="line">  isFile <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll.FD 依赖 poll.pollDesc 实现poll功能。poll.pollDesc 实现了 IO polling 的功能。poll.pollDesc 有一系列的方法，比如 init、wait、close、prepare 等都是对 runtime_pollXXX 函数系列的封装，下面诗pollDesc的部分逻辑:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">  runtimeCtx <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverInit sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">  serverInit.Do(runtime_pollServerInit)</span><br><span class="line">  ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">  &#125;</span><br><span class="line">  pd.runtimeCtx = ctx</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术类</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的npm依赖环境以及博客部署备忘录</title>
    <url>/posts/28dcdc4c.html</url>
    <content><![CDATA[<h3 id="pug-以及-stylus-的渲染器"><a href="#pug-以及-stylus-的渲染器" class="headerlink" title="pug 以及 stylus 的渲染器"></a>pug 以及 stylus 的渲染器</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer-pug</span> hexo<span class="literal">-renderer-stylus</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<h3 id="butterfly开启本地搜索"><a href="#butterfly开启本地搜索" class="headerlink" title="butterfly开启本地搜索"></a>butterfly开启本地搜索</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator-search</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<h3 id="开启hexo-abbrlink文章链接"><a href="#开启hexo-abbrlink文章链接" class="headerlink" title="开启hexo-abbrlink文章链接"></a>开启hexo-abbrlink文章链接</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-abbrlink</span> <span class="literal">--save</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span>     <span class="comment"># 将原来文章的地址修改为这个</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 并添加如下配置：</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment">#support dec(default) and hex</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment">#(true)Process draft,(false)Do not process draft. false(default) </span></span><br></pre></td></tr></table></figure>

<h3 id="部署必备插件"><a href="#部署必备插件" class="headerlink" title="部署必备插件"></a>部署必备插件</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-deployer-git</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<h3 id="开启百度站长主动推送文章链接"><a href="#开启百度站长主动推送文章链接" class="headerlink" title="开启百度站长主动推送文章链接"></a>开启百度站长主动推送文章链接</h3><p>安装依赖</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-baidu-url-submit</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<p>修改配置文件<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置百度主动推送</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">200</span>  <span class="comment">#比如200，代表提交最新的200个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">www.kimtoli.com</span> <span class="comment"># 在百度站长平台中注册的域名，这个改为你自己的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">your_token</span> <span class="comment"># 百度站长token字段</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 新链接会保存在此文本文档里（文本文件的文件名）</span></span><br></pre></td></tr></table></figure>

<p>加入新的deploy项</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:XXX/XXX.github.io.git</span>  <span class="comment"># Github地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span>  <span class="comment"># 这一行是新增的配置</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术类</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一些很有用的JavaScript代码</title>
    <url>/posts/bbf49370.html</url>
    <content><![CDATA[<h3 id="获取浏览器cookie值"><a href="#获取浏览器cookie值" class="headerlink" title="获取浏览器cookie值"></a>获取浏览器cookie值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cookie = name =<span class="string">`; <span class="subst">$&#123;<span class="variable language_">document</span>.cookie&#125;</span>`</span>.<span class="title function_">split</span>(<span class="string">`; <span class="subst">$&#123;name&#125;</span>=`</span>).<span class="title function_">pop</span>().<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>).<span class="title function_">shift</span>();</span><br><span class="line"><span class="title function_">cookie</span>(<span class="string">&#x27;_ga&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="将RGB转换为16进制"><a href="#将RGB转换为16进制" class="headerlink" title="将RGB转换为16进制"></a>将RGB转换为16进制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">rgbToHex</span> = (<span class="params">r, g, b</span>) =&gt;</span><br><span class="line"><span class="string">&quot;#&quot;</span> + ((<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + (r &lt;&lt; <span class="number">16</span>) + (g &lt;&lt; <span class="number">8</span>) + b).<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">rgbToHex</span>(<span class="number">0</span>, <span class="number">51</span>, <span class="number">255</span>);</span><br></pre></td></tr></table></figure>

<h3 id="复制到剪切板"><a href="#复制到剪切板" class="headerlink" title="复制到剪切板"></a>复制到剪切板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> copyToClipboard = (text) =navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(text);</span><br><span class="line"><span class="title function_">copyToClipboard</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="检查日期是否有效"><a href="#检查日期是否有效" class="headerlink" title="检查日期是否有效"></a>检查日期是否有效</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDateValid = (...val) =!<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(...val).<span class="title function_">valueOf</span>());</span><br><span class="line"><span class="title function_">isDateValid</span>(<span class="string">&quot;December 17, 1995 03:24:00&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>找出一年中的某一天（即给出一个日期，程序给出属于本年的第多少天）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dayOfYear</span> = (<span class="params">date</span>) =&gt;</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>((date - <span class="keyword">new</span> <span class="title class_">Date</span>(date.<span class="title function_">getFullYear</span>(), <span class="number">0</span>, <span class="number">0</span>)) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">dayOfYear</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// Result: 272</span></span><br></pre></td></tr></table></figure>

<h3 id="将字符串首字母大写"><a href="#将字符串首字母大写" class="headerlink" title="将字符串首字母大写"></a>将字符串首字母大写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> capitalize = str =str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">capitalize</span>(<span class="string">&quot;follow for more&quot;</span>)</span><br><span class="line"><span class="comment">// Result: Follow for more</span></span><br></pre></td></tr></table></figure>

<h3 id="计算两个日期之间相差的天数"><a href="#计算两个日期之间相差的天数" class="headerlink" title="计算两个日期之间相差的天数"></a>计算两个日期之间相差的天数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dayDif = (date1, date2) =<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(date1.<span class="title function_">getTime</span>() - date2.<span class="title function_">getTime</span>()) / <span class="number">86400000</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">dayDif</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2020-10-21&quot;</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2021-10-22&quot;</span>))</span><br><span class="line"><span class="comment">// Result: 366</span></span><br></pre></td></tr></table></figure>

<h3 id="清除所有cookie"><a href="#清除所有cookie" class="headerlink" title="清除所有cookie"></a>清除所有cookie</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clearCookies = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>).<span class="title function_">forEach</span>(cookie =<span class="variable language_">document</span>.<span class="property">cookie</span> = cookie.<span class="title function_">replace</span>(<span class="regexp">/^ +/</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/=.\*/</span>, <span class="string">`=;expires=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>).toUTCString()&#125;</span>;path=/`</span>));</span><br></pre></td></tr></table></figure>

<h3 id="生成随机16进制"><a href="#生成随机16进制" class="headerlink" title="生成随机16进制"></a>生成随机16进制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> randomHex = () =<span class="string">`#<span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">0xffffff</span>).toString(<span class="number">16</span>).padEnd(<span class="number">6</span>, <span class="string">&quot;0&quot;</span>)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">randomHex</span>());</span><br><span class="line"><span class="comment">// Result: #92b008</span></span><br></pre></td></tr></table></figure>

<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> removeDuplicates = (arr) =[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">removeDuplicates</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>]));</span><br><span class="line"><span class="comment">// Result: [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="从URL中获取查询参数"><a href="#从URL中获取查询参数" class="headerlink" title="从URL中获取查询参数"></a>从URL中获取查询参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getParameters = (<span class="variable constant_">URL</span>) =&#123;</span><br><span class="line"><span class="variable constant_">URL</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;&#x27;</span> + <span class="built_in">decodeURI</span>(<span class="variable constant_">URL</span>.<span class="title function_">split</span>(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>]).<span class="title function_">replace</span>(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;\\&quot;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&quot;,&quot;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/=/g</span>, <span class="string">&#x27;&quot;:&quot;&#x27;</span>) +<span class="string">&#x27;&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable constant_">URL</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getParameters</span>(<span class="variable language_">window</span>.<span class="property">location</span>)</span><br><span class="line"><span class="comment">// Result: &#123; search : &quot;easy&quot;, page : 3 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="从日期中获取“时分秒”格式的时间"><a href="#从日期中获取“时分秒”格式的时间" class="headerlink" title="从日期中获取“时分秒”格式的时间"></a>从日期中获取“时分秒”格式的时间</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timeFromDate = date =date.<span class="title function_">toTimeString</span>().<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">timeFromDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2021</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>)));</span><br><span class="line"><span class="comment">// Result: &quot;17:30:00&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="确认奇偶数"><a href="#确认奇偶数" class="headerlink" title="确认奇偶数"></a>确认奇偶数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过数据%2来判断并返回布尔类型</span></span><br><span class="line"><span class="keyword">const</span> isEven = num =num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEven</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// Result: True</span></span><br></pre></td></tr></table></figure>

<h3 id="回到顶部（适用于网页右下角快捷返回功能）"><a href="#回到顶部（适用于网页右下角快捷返回功能）" class="headerlink" title="回到顶部（适用于网页右下角快捷返回功能）"></a>回到顶部（适用于网页右下角快捷返回功能）</h3><p>//通过将x、y设置为0来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> goToTop = () =<span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="title function_">goToTop</span>();</span><br></pre></td></tr></table></figure>

<h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverse = str =str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="title function_">reverse</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="comment">// Result: &#x27;dlrow olleh&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="检查数组是否为空"><a href="#检查数组是否为空" class="headerlink" title="检查数组是否为空"></a>检查数组是否为空</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过对数组长度判断来确定是否为空</span></span><br><span class="line"><span class="keyword">const</span> isNotEmpty = arr =<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) &amp;&amp; arr.<span class="property">length</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isNotEmpty</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// Result: true</span></span><br></pre></td></tr></table></figure>

<h3 id="获取用户选定的文本"><a href="#获取用户选定的文本" class="headerlink" title="获取用户选定的文本"></a>获取用户选定的文本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getSelectedText = () =<span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSelectedText</span>();</span><br></pre></td></tr></table></figure>

<h3 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffleArray = (arr) =arr.<span class="title function_">sort</span>(() =<span class="number">0.5</span> - <span class="title class_">Math</span>.<span class="title function_">random</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">shuffleArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br><span class="line"><span class="comment">// Result: [ 1, 4, 3, 2 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="检查用户是否处于暗模式"><a href="#检查用户是否处于暗模式" class="headerlink" title="检查用户是否处于暗模式"></a>检查用户是否处于暗模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDarkMode = <span class="variable language_">window</span>.<span class="property">matchMedia</span> &amp;&amp; <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>).<span class="property">matches</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isDarkMode) <span class="comment">// Result: True or False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术类</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。</title>
    <url>/posts/fcce4138.html</url>
    <content><![CDATA[<h3 id="腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。"><a href="#腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。" class="headerlink" title="腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。"></a>腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。</h3><p>4月7日，腾讯视频与抖音集团宣布达成合作，双方将围绕长短视频联动推广、短视频衍生创作开展合作。腾讯视频将向抖音授权其享有信息网络传播权及转授权权利的长视频。此外，腾讯视频与抖音还明确了短视频衍生创作的方式、发布规则，共同促进短视频的创作、传播。</p>
<p>这次合作，也被外界视为“世纪大和解”。此前，腾讯和抖音曾因版权问题多次对簿公堂，也曾在公开场合互相炮轰。如今双方的握手言和，意味着双方在长短视频创作领域找到了利益共通点。在短视频的直接交锋之外，腾讯的长视频资源也可以以版权授权的形式，授予它的直接竞争对手。</p>
<p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102130.jpg" alt="腾讯和抖音合作"></p>
<h3 id="腾讯自营短视频产品的始末"><a href="#腾讯自营短视频产品的始末" class="headerlink" title="腾讯自营短视频产品的始末"></a>腾讯自营短视频产品的始末</h3><p>值得一提的是，腾讯其实是国内最早布局短视频的互联网公司之一，早在2013年，就上线了微视，但当时的战略，不过是对标海外产品的进行新产品尝试，并没有在战略上重视，由于总办对其市场化的误判，最后在2015年开始实质上放弃。</p>
<p>快手和抖音火爆后，腾讯希望重新回到这条赛道上来，这几年，腾讯帝国内部各路诸侯先后发布了哈皮、yoo视频等十余款短视频APP，最后基本都以失败告终。</p>
<p>2017年，以抖音和快手为代表的短视频持续高歌猛进，腾讯开始复活微视，甚至提到了“战略级”。但微视这款产品似乎受到了诅咒，内部资源和组织难以顺畅打通，发力艰难，在外部，则一直不被主流圈子看好，现在依然处在艰难爬坡的状态，目前看只能作为防御性产品拖住竞争对手。</p>
<p>也是在这个时候，腾讯微视的小2联系到了我，顺利入住的微视MCN合作机构，作为集团“战略级”产品，扶持当然是不能少了，腾讯集团公司花了巨款砸在了内容补贴上面，补贴方式为cpm结算，实不相瞒。。我在刚开始做的时候，最风口的时刻，单微视这一个项目单月拿了60多个W的流水（包含达人50%的分成，以及将近4万块的增值税），流水月入百万的MCN机构老板我微信朋友圈也加着几个，只能说腾讯在力度方面真的狠上了。。。。</p>
<p>但是，投入巨大资源的微视在2019年并没有完成4000万DAU的目标，从腾讯PCG负责人任宇昕在年会上定2020年新目标为5000万DAU的目标来看，2019年的目标是远远未达标的。当然，微视最大的问题，不是缺增长，而是缺留存，快手与抖音的留存都在80%左右，而微视仅在43%上下徘徊，这就非常尴尬。在2020年，它大概率会被认定为一款只有防守价值的产品。</p>
<p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102045.jpg" alt="腾讯微视"></p>
<h3 id="曾多次对簿公堂，创始人曾朋友圈“互怼”"><a href="#曾多次对簿公堂，创始人曾朋友圈“互怼”" class="headerlink" title="曾多次对簿公堂，创始人曾朋友圈“互怼”"></a><strong>曾多次对簿公堂，创始人曾朋友圈“互怼”</strong></h3><p>2018年5月，抖音成为全球第一季度App Store下载量最高应用时，字节跳动创始人张一鸣在朋友圈写下这样一句话，“微信的借口封杀，微视的抄袭搬运，挡不住抖音的步伐。”腾讯创始人马化腾随即在下方回应称：“可以理解为诽谤。”</p>
<p>两名互联网大佬朋友圈公开互怼背后，是腾讯和字节之间“头腾大战”持续升级的一个缩影。特别是在短视频领域，当时占据杆位的抖音，对迟迟未能形成突破的腾讯，形成巨大压力。版权，成了双方交锋的一个发泄口。</p>
<p>公开资料显示，腾讯和抖音之间就视频版权有过多次纠纷。去年10月26日，西安市中级人民法院就《云南虫谷》案作出一审判决。法院认为，抖音平台上有大量用户对涉案作品实施侵权行为，需赔偿腾讯经济损失及合理费用3240余万元，刷新了全国法院网络影视版权案件赔偿纪录。</p>
<p>公开资料显示，《云南虫谷》为腾讯旗下企鹅影视出品的悬疑冒险网络剧，改编自天下霸唱小说《鬼吹灯之云南虫谷》。</p>
<p>2021年6月，腾讯向重庆一中院起诉，认为抖音平台内的用户上传内容侵害了《斗罗大陆》著作权，要求法院判令抖音赔偿经济损失并合理支出共计6160万元，此后又将索赔金额从6160万元提高到8亿元。</p>
<p>同年，字节跳动也在重庆市第一中级法院起诉腾讯，原因是腾讯视频上存在大量涉及电视剧《亮剑》的侵权视频，要求法院判令腾讯删除侵权视频、发布声明消除影响，并赔偿经济损失1000万元。</p>
<p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102155.jpg" alt="腾讯VS抖音"></p>
<h3 id="视频号和抖音的产品整合？"><a href="#视频号和抖音的产品整合？" class="headerlink" title="视频号和抖音的产品整合？"></a><strong>视频号和抖音的产品整合？</strong></h3><p>微信视频号的崛起，应该也为腾讯视频对外版权合作提供了更多底气。</p>
<p>眼下，视频号已成微信业务中当之无愧的“C位”。据腾讯最新财报，微信视频号的使用时长已达到朋友圈的1.2倍。数据显示，去年第四季度，视频号季度收入超过10亿，去年视频号直播带货销售增长800%，累计有收入的作者数对比2021年增长2.64倍。</p>
<p>腾讯CEO马化腾也曾在内部员工大会上的讲话中提到，微信事业群最亮眼的业务是视频号，基本上是全公司的希望。</p>
<p>不过，腾讯高管也在财报后的电话会议中坦言，相比竞争对手的短视频服务，视频号目前的广告数量仍处于相对落后的水平。相比抖音，腾讯视频号也尚未孵化出头部创作者。</p>
<p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102213.jpg" alt="视频号"></p>
<h3 id="长短视频平台大和解"><a href="#长短视频平台大和解" class="headerlink" title="长短视频平台大和解"></a><strong>长短视频平台大和解</strong></h3><p>可见的是，这并不是长短视频平台的首次牵手。去年7月19日，抖音集团和爱奇艺宣布达成合作。爱奇艺将向抖音集团授权其内容资产中拥有信息网络传播权及转授权的长视频内容，用于短视频创作，双方也对解说、混剪、拆条等短视频二创形态做出具体约定。</p>
<p>去年6月30日，快手曾宣布与乐视视频达成二创相关授权合作。这意味着快手创作者可以对乐视视频独家自制版权作品进行剪辑及二次创作，并发布在快手平台内。</p>
<p>“长短视频之间并非简单机械的竞争关系，更应是一种共生关系。且在当前大环境下，长短视频抱团合作也能取得不错效果。”浙江大学国际联合商学院数字经济与金融创新研究中心研究员盘和林告诉澎湃新闻记者。</p>
<p>在他看来，腾讯的利益在于通过短视频的二创强化自有视频IP的传播度，从而实现流量增长，提高IP播放量，夯实平台盈利能力，等于免费通过抖音短视频引流。而抖音则保留了二创这一关键的抖音短视频内容模式，为抖音平台上的自媒体争取到更多可以二创的IP内容。</p>
<p>“从商业模式分析，腾讯视频和抖音不是竞争对手。腾讯视频的营收来源依赖会员和广告，而抖音则通过电商和广告盈利，两者的客户重合度并不高。”艾媒咨询CEO张毅告诉澎湃新闻记者，“对于腾讯视频而言，抖音的短视频二创是很好的引流手段和工具。对于抖音而言，和腾讯合作也为创作者提供了更多改编空间。”</p>
]]></content>
      <categories>
        <category>互联网</category>
        <category>新媒体</category>
      </categories>
      <tags>
        <tag>新媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>江怀安对我的大献殷勤不为所动，可我想要的只能是我的，直到他被我绑在床榻之上</title>
    <url>/posts/bdf69bea.html</url>
    <content><![CDATA[<p>【明月照沟渠】<br>江怀安十二岁的时候，我就对人家一见倾心。<br>面对我的大献殷勤他不为所动，坚贞不屈的模样，在众人前大喊：“江某此生，宁为庙里僧，不上公主塌”<br>我笑的云淡风轻，江怀安不懂我，我想要的，只能是我的。<br>直到他被我绑在床榻之上。<br>我在上，他在下。<br>我的胞妹他的心上人在门外望。<br>“喊啊！好让门外人听的清楚些。”<br>1、<br>十岁之前我都在院门口耍大刀，活在我阿爷给我编的女侠小说梦里。<br>十岁，他顺着造反队伍做了皇帝。<br>我之前吃的都是糠噎菜，坐我阿爷大腿上，读的不是圣贤书，学的骂大娘。<br>我第一次见到江怀安，就对他颇感兴趣。<br>寒冬腊月。<br>我坐着阿爷的骏马上，居高临下，疾驰而来卷起沙土。<br>惹得底下的人被咳了几声，待沙尘散去。<br>我看清了脸，他生的白嫩，双眼清澈透亮，像沙漠里的星子。<br>亮的能把人吸进去。<br>我阿爷抱着我，目光冷漠的扫过江怀安，语气不善：“哪家的姑娘，经不起风沙，可得抓稳了，别让老子的马蹄子踹着你。”<br>“阿枝，我儿，还要比你黑些，壮些。”<br>2、<br>江怀安的爹谄媚的笑着跟我和阿爷介绍：“陛下、公主恕罪，在下小儿姓江字怀安，十二实岁，竖子年幼还望海涵。”<br>“江怀安？”我在心里默念着他的名字，然后呲着牙朝他咧嘴笑：“你生的可真好看！”<br>他不回话，一双漆黑眸子不卑不亢的看着我，疏远又莫离。<br>他爹使劲儿推了一把，又在他后背狠狠打上几下，恶狠狠的骂：“公主抬举你，你还不跪谢。”<br>江怀安不为所动，他爹从袖子里抻出一长跟细柳条枝，狠狠在他背上抽打。<br>他愣是一滴泪没留。<br>“不要，不要打他！”<br>小时候，我不听话，出院子，瞎溜达着玩，被人贩子拐走过。<br>爹从城里买了肉赶摊子回来的早，举起刀“什么杂碎，敢偷老子的儿？！”<br>赶的那人屁滚尿流。<br>娘回来打我拿的就是细柳条抽的我，疼的我兹拉瓦拉叫。<br>3、<br>“不要，不要打他！”<br>我下了马，跑过去推开那打人的爹。<br>将江怀安挡在身前。<br>“你疼不疼”<br>他偏过头，视线对上我的眼神，语气不容置喙：“多管闲事”<br>我愣了楞，收回了手，嘴角勾起一个弧度。<br>“打死算了！”<br>4、<br>“哈哈哈哈哈哈，刘大人，莫怪，我儿说话就是直冲“<br>“枝儿，上马，回宫。”<br>十二岁我做了公主，他做了我的臣子。<br>5、<br>我贪图美色日日泡在江府。<br>送书、送礼，天天缠着，我要让全京城的世家小姐都知道。<br>他—江怀安，是我晋阳公主沈枝意的。<br>开始的时候是惊恐冷漠至极，一次一次碍着身份有别的婉拒。<br>“公主，在下无能，无闲，需得读书、习字考功名，报效朝廷，难入公主青眼。”<br>我只是笑，偏着头看着他：“爱卿，自古男子无才，英俊清秀便是德，这点你已经做的够好了。”<br>为了让他分辨出我与旁的女子不同，我劳心费神苦追一年，可他的心比三月飞雪还冷，不为所动。<br>我与华阳谈心，哀声叹气，我问她：“暖暖，我是真的对江怀安一见倾心，想让他做我驸马，你说他是真不想还是装不想？”<br>华阳是小我四岁的妹妹，生得貌美，言行举止不刻板。<br>出口成章是先生口中读书的好料子，八面玲珑惹得满朝文武群臣追捧。<br>经常吐出一些我听不懂的词。<br>她教我：“沈枝意，你一个公主怎么活得这么窝囊，送钱又送礼，软的不行你就硬来呗”<br>软的不行，我就来硬的？<br>她活泼的朝我眨眨眼：“就讷！”<br>啥？！<br>“霸王硬上弓呗，被破了身的男的，都不值钱了，哪家千金还敢要他？还不得乖乖跟你回府？！”<br>6、<br>我听进去了。<br>他读书。<br>我便骑马，骑得还是他这匹15岁秀色可餐的小马。<br>即便在不情愿，他也照做，逼的他嘴里振振有词：“沈枝意，像你这般女子，我江怀安这辈子不会娶。”<br>“无妨，本公主纳你入赘便可。”<br>一巴掌打在他屁股上：“快点，驾。”<br>他红着个大脸梗着脖子，一言不发，又驮着我，走了一圈又一圈。<br>我以为这一走就是一辈子。<br>直到沈怀安见到了华阳。<br>他告诉我：“沈枝意，不要再纠缠了，我有心仪之人了，你想让她怎么看我，公主殿下养在江府的面首吗？你怎么样才能放过我？！”<br>回宫之后，我食之无味，坐在院子里一遍又一遍的写着“江怀安”的名字。<br>“我病了，暖暖。”<br>华阳说我这叫失恋了。<br>反正我“总角之宴，言笑晏晏”的美梦，碎的稀里哗啦。<br>7、<br>江怀安最喜欢和华阳凑一起。<br>我在院子里耍三套大刀心法，看一部话本子，她两才能从房间出来。<br>两人关上门子，也不知道谈什么。<br>反正每次华阳出来，都会羞涩的捂着嘴笑，然后跑到我身边，扑我怀里撒娇直嚷着回家。<br>江怀安站到一旁耐心的叮嘱：“小心，别摔到。”<br>语气是我从未见过的温柔，我还以为他是天生的性子冷淡，没想到是唯独面对我，对别人他也可以柔情似水。<br>我心里不舒服，说不上来哪难受。<br>所以每次临走时，我都会拽着江怀安的衣领子，到偏僻角落。<br>“今天多聊了半个时辰。”<br>他脸红成一颗大苹果，不敢看我。<br>我绕有兴趣捏起他的下巴：“要我亲自动手吗？”<br>他抬眼，扒拉掉我的手，像一只会咆哮的小兽，湿了眼眶：“沈枝意！你粗鄙不堪!”<br>我心情愉悦的哼了几声。<br>他无奈凑上前贴上我的脸，然后脸变得更红。<br>甩甩衣袖，往外走，任我怎么叫也不回头，是只倔强的小马驹。<br>每次都闹一番。<br>读书人还是要带点自尊和骨气在身上的，本公主很欣赏。<br>我满意的回味，彪上华阳的胳膊大喊一句：“本公主回宫喽”<br>华阳上下打量我的雀跃：“沈枝意，你又欺负江怀安？”<br>“那又如何反正他江怀安，本该是我夫，早晚都是我夫，只能是我夫”说这句时我在江府门外，看到了鬼鬼祟祟躲在假山后的江怀安，我笑的肆意。<br>她微微抬高了嗓音：“沈枝意，你别恋爱脑啊”<br>我蹙着眉，语重心长：“暖暖，你无人时，也应该唤我阿姐才对。”<br>后来，我才知道，江怀安未必是出来送我的。<br>我轻薄他气急败坏，捂着脸跑进屋也不是因为害羞，只是不想被喜欢的人看到自己无能的一面罢了。<br>4、<br>“就是京中学时最粗浅的女儿家，也不似你这般粗鄙不堪”<br>爱慕江怀安的世家小姐从来不在少数，这么直白又毫不留情面的还是第一个。<br>我认真反思过自己的问题，想着将来江怀安高中。<br>正房大娘子不能是个白丁。<br>我求了父皇，指派江怀安当我教课先生。<br>父皇很是欣慰，随口一句“不愧他妈的是老子闺女，就是上进。”<br>旁边的宦官咳嗽两声，父皇红着脸才觉得不妥，轻咳一声，大手一挥。<br>“国之栋梁，你悠着点！”<br>想来父皇也知道我的得行，隐晦的提醒我别玩太过，他都可以兜底。<br>我暗暗发誓，这次一定要拿下，待到假以时日，做状元夫人。<br>开始江怀安教我写字。<br>我写不明白，示意他握着我的手手把手教。<br>他锁着眉，低头作揖：“君臣有别”<br>“你要违抗皇命？”<br>“微臣不敢”<br>我欣慰的笑了，这公主身份还是有些用处的。<br>江怀安攥住我的手，指节粗粒，我细细摩擦，笑意盈盈的看向他。<br>直到把我的名字，木字旁的捺划出去一大截。<br>我轻靠怀里，听着他心脏跳的震天响，不怀好意的覆到他耳边：“怀安哥哥，你乱了。”<br>他瞧着我愣了一瞬，耳根子红的像山楂，好看的紧，垂着头：“是”<br>5、<br>自那以后，我变得一发不可收拾。<br>无所不用其极。<br>挑着时辰，沐浴更衣，支开宫女婆子，让他红着脸给我递小衣。<br>“怀安哥哥，我这衣服上绣的牡丹好看吗”<br>他把着小衣，攥出褶子，眸色晦暗不明，脸红成一个可口的大苹果。<br>像是从牙缝里挤出来俩个字<br>“好看”<br>我：“什么好看”<br>“牡丹”<br>我没忍住嗤笑出来，在水里扑腾的欢。<br>“怀安哥哥，你可看好了？那上边绣的不是牡丹，是芍药。”<br>我又缠着他给我梳发，湿漉漉的眼眸回头看，夹着嗓子问“怀安哥哥，我美吗？”<br>后来有几日他扛不住了，告了假。<br>华阳风风火火往我院里赶，上来就是一句：“沈枝意，你把人家玩坏了？”<br>我滋滋两声，装作端庄严肃：“暖暖，慎言！”<br>这两句还是江怀安教给我的，他经常说，我便也记住了。<br>5、<br>只是那天以后，华阳也塞到我院子里还和我分着江怀安上课。<br>两人经常说说笑笑。<br>华阳被绊，江怀安也不避嫌了立马扶住。<br>在课上，来人诗书会友，把我晾在一旁。<br>我拉着他进屋，他又拘谨的说不妥。<br>我是农户出身，他一个读书人哪有我力气大。<br>我拽起他，扣在床板上。<br>他深知我不知礼数和羞耻，但还是被我疯狂的举动吓得眼睑抽搐。<br>又羞又气，我捂上他的嘴，坏笑的说：“江怀安，你叫这么大声，想让谁听见。”<br>我不由分说狂咬了上去，拉着他的外衫，他震惊的与我反抗。<br>正在此时，我的门被拍的震天响。<br>“阿姐，你看到怀安哥哥了嘛？我寻不到他了。”<br>江怀安咬牙切齿，推开我。<br>我心头抹过一丝烦躁，华阳何时这么没眼力价，差点刚才就要有姐夫了。<br>6、<br>自那以后，江怀安以学疏才浅辞去我先生一职。<br>我的日子变得寡淡无味，期期艾艾闲来无事学了几句诗句。<br>华阳听说我发奋图强，搬着茶糕在我这欣赏。<br>“晓看天色暮看云”<br>华阳喝了口茶：“嗯<del>，然后呢？”<br>“行也思君，坐也思君。”<br>“噗”华阳一口水没咽，全喷出来。<br>她深吸一口气，仿佛用了很大力气才把手里的茶杯轻轻落下，嘴里喃喃自语：“没事，没事，哪个女主不是恋爱脑发家的，不气，不气。”<br>又走到我跟前，双手抓住我白嫩的细肩，疯狂摇晃。<br>“我倒要看看你这些年吃了多少江怀安给你喂的恋爱脑，你没有自己的生活了吗？”<br>声音不大，却让我猛然惊醒。<br>她掰过我的肩膀，认真的望着我。<br>“沈枝意，你想不想过不一样的生活，过一过普通人的生活，做富商、做大人、甚至做女皇！！！”<br>我颤抖着嗓子说“我想做地瓜，又香又甜阿娘小时候经常做的。”<br>7、<br>马上是他的生辰了。<br>我找了平日他的同窗，好友，为他庆生。<br>华阳点子多，说过生日要做蛋糕、烟花，很罗…什么曼什么克，我也不懂给她银子，她说帮我准备。<br>只是蛋糕需要我亲手做，更有诚意。<br>趁着江怀安去学堂，我带了几个丫鬟婆子，亲力亲为，<br>华阳带着我一步一步的做，打鸡蛋到手抽筋，但想到江怀安看见时开心我就一点也不觉得累。<br>华阳看我忙前忙后的样子，一脸嫌弃：“江怀安上辈子拯救银河系了吧，遇见你沈枝意为他劳心劳力。”<br>她又很担心的看着我：“沈枝意，他不值得，所有人都不值得，你这样对待”<br>我不以为然。<br>她在我身后叹气：“算了！可能真的需要按照剧情一步一步来，是我太心急了！”<br>屋里一片黑漆，我捧着蛋糕走到江怀安面前。<br>我笑的娇羞：“怀安，这是我为你生辰亲手做的，暖暖说…….”<br>“够了！”<br>我的笑容凝固在脸上。<br>他反手将我手里的蛋糕，摔在地上，鸡蛋打出的白色物，溅了我一身，脸上也有。<br>门外的众人听见动静。<br>陆续走进来，跟他抱拳，笑意盈盈的道贺。<br>他对我的嫌恶还存在眼底，让我看的一览无余。<br>我就这样仰着头看他，他也低着头看我，我看着他眼里倒影出的我，狼狈不堪。<br>红了眼眶，脏了裙摆。<br>满堂宾客，我顿了顿，嘴角扬起一抹微笑，故作轻松：“哦</del>原来这蛋糕就是用来糊脸的，像胭脂。”<br>我取下脸上的一点，伸出手指抹了过去：“生辰快乐，祝你永远平安，江怀安。”<br>8、<br>京中有人传出，皇帝欲将江怀安赐为驸马，是哪位公主的却不知。<br>毕竟华阳昨日刚刚及笄。<br>我转着茶杯，微微垂眼。<br>贴身伺候的小宫女迈着小步子匆匆赶来。<br>秀眉紧蹙着，朝我抱怨：“公主，您还在这喝查呢，外头的那些碎嘴子都传呢，说江府小少爷要嫁到华阳公主府去。”<br>小丫头只是随意讲了几句，听的我身体凉意多了几分。<br>“不会的，我们十二岁便认识了，牵过手，也亲过，他还为我束过发，他说过……”<br>我后知后觉<br>“对了，他没说过，他没说过要娶我……”<br>门外雨打风急。<br>我晃着衣摆跑在前，小丫头举着伞跟不上我。<br>“公主，快跑慢些，淋了雨，会病”<br>到了江府前，几个小厮没拦住我，拦住了后面的小丫头。<br>气的她，喊着他们大胆：“公主随侍”<br>我跑的极快，心脏伴随着撕裂感的，大声喘息。<br>“江……”<br>伴随着雨声，里边传出一句：“父亲，若是皇上不收回成命，执意将沈枝意与我赐婚，我宁肯剃度为僧，也不上公主榻。”<br>“宁为庙中僧，不上公主榻”<br>我嘴里默念，大脑一片混沌，茫然不已。</p>
<p><strong><a href="https://mparticle.uc.cn/story.html?p=sVXrL&wm_cid=591171382417562624">点我查看全文</a></strong></p>
]]></content>
      <categories>
        <category>小说</category>
        <category>古言</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
</search>
