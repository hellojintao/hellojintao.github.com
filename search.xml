<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go中netpoll的工作机制</title>
    <url>/posts/794f771b.html</url>
    <content><![CDATA[<h2 id="netpollGenericInit-初始化-poller"><a href="#netpollGenericInit-初始化-poller" class="headerlink" title="netpollGenericInit 初始化 poller"></a>netpollGenericInit 初始化 poller</h2><p>netpollGenericInit 保证 poller 被初始化，原子变量netpollInited保证其仅被初始化一次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollGenericInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.Load(&amp;netpollInited) == <span class="number">0</span> &#123;</span><br><span class="line">    lockInit(&amp;netpollInitLock, lockRankNetpollInit)</span><br><span class="line">    lock(&amp;netpollInitLock)</span><br><span class="line">    <span class="keyword">if</span> netpollInited == <span class="number">0</span> &#123;</span><br><span class="line">      netpollinit()</span><br><span class="line">      atomic.Store(&amp;netpollInited, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;netpollInitLock)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数只是一个壳，初始化逻辑封装在netpollinit函数中，依赖于平台具体的实现。linux下，init的逻辑是:</p>
<ol>
<li>通过epoll_create1系统调用创建 epoll fd</li>
<li>创建一对 read/write pipe。pipe的一个特性是向 write pipe写入数据，read pipe 就能收到同样的数据</li>
<li>通过epoll_ctl将 write pipe 对应的fd 加入到监听列表</li>
</ol>
<p>单独创建一对pipe后，runtime就能够按需中断epoll_wait，让netpoll函数立即返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">  <span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">    epfd = epollcreate(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, -epfd)</span><br><span class="line">      throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    closeonexec(epfd)</span><br><span class="line">  &#125;</span><br><span class="line">  r, w, errno := nonblockingPipe()</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;runtime: pipe failed with&quot;</span>, -errno)</span><br><span class="line">    throw(<span class="string">&quot;runtime: pipe failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ev := epollevent&#123;</span><br><span class="line">    events: _EPOLLIN,</span><br><span class="line">  &#125;</span><br><span class="line">  *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd</span><br><span class="line">  errno = epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, -errno)</span><br><span class="line">    throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  netpollBreakRd = <span class="type">uintptr</span>(r)</span><br><span class="line">  netpollBreakWr = <span class="type">uintptr</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="netpoll函数"><a href="#netpoll函数" class="headerlink" title="netpoll函数"></a>netpoll函数</h2><p>netpoll函数的功能是检查可用的网络连接，它的工作流程是(happy path)：</p>
<ol>
<li><p>创建size=128的epollevent数组, 以接收事件</p>
</li>
<li><p>调用epollwait等待事件: 依赖epoll_wait系统调用</p>
</li>
<li><p>遍历epoll events，对于每个event</p>
</li>
<li><ul>
<li>创建一个pollDesc对象</li>
<li>调用netpollready，找到对应的goroutine，并将其状态从pdWait修改为pdReady</li>
</ul>
</li>
<li><p>返回pdReady状态的 goroutine列表 (gList)</p>
</li>
</ol>
<p>struct pollDesc中包含两个信号量字段，可以表示四种状态:</p>
<ol>
<li><p>pdReady: io ready信号等待被接收，goroutine可以消费这个信号，逻辑上是把信号量改成nil</p>
</li>
<li><p>pdWait: goroutine已经准备好在该信号量上阻塞，但还没有阻塞；</p>
</li>
<li><ul>
<li>如果goroutine通过gopark阻塞，状态会变成G pointer</li>
<li>如果并发的io ready信号到达，状态会改成pdReady</li>
<li>如果并发的timeout/close信号到达，状态会被改成nil</li>
</ul>
</li>
<li><p>G pointer: goroutine被阻塞在信号量上，可以被下面两类事件唤醒:</p>
</li>
<li><ul>
<li>io ready信号到来时，状态被修改好pdReady</li>
<li>timeout/close信号到来时，状态被修改为nil</li>
</ul>
</li>
<li><p>nil: 不是上面三种状态</p>
</li>
</ol>
<p>对应一些辅助函数:</p>
<ul>
<li>netpollblock 函数将goroutine状态从 pdReady 转化成 pdWait，并gopark当前goroutine</li>
<li>netpollunblock 函数将goroutine状态从 pdWait 转换为 pdReady 或 nil</li>
</ul>
<p>netpoll函数的代码在runtime/netpoll_epoll.go中，部分代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> gList &#123;</span><br><span class="line">  <span class="comment">// epoll fd 为-1，说明不需要poll</span></span><br><span class="line">  <span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line">  <span class="comment">// ...省略一段代码</span></span><br><span class="line">  <span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">  n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n != -_EINTR &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: epollwait on fd&quot;</span>, epfd, <span class="string">&quot;failed with&quot;</span>, -n)</span><br><span class="line">      throw(<span class="string">&quot;runtime: netpoll failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If a timed sleep was interrupted, just return to</span></span><br><span class="line">    <span class="comment">// recalculate how long we should sleep now.</span></span><br><span class="line">    <span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> retry</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> toRun gList</span><br><span class="line">  <span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">    ev := &amp;events[i]</span><br><span class="line">    <span class="keyword">if</span> ev.events == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">      <span class="comment">// ... read pipe 有数据</span></span><br><span class="line">      <span class="comment">// 不需要唤醒任何goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line">    <span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">      mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">      mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">      pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">      pd.setEventErr(ev.events == _EPOLLERR)</span><br><span class="line">      <span class="comment">// 将goroutine置为 pdReady</span></span><br><span class="line">      <span class="comment">// 并添加到toRun *gList</span></span><br><span class="line">      netpollready(&amp;toRun, pd, mode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toRun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注: netpollready 函数借助于netpollunblock修改goroutine状态，并将其加到 io ready 的 goroutine list。</p>
<p>runtime在调用 netpoll 时，通常采用的是 nonblock 模式(delay=0), 只有在 findrunnable 的最后一个环节，会检查是否有单独的M(GMP中的M)进行net polling，如果没有，会block等待delay参数指定的时间。</p>
<h2 id="netpollBreak-函数"><a href="#netpollBreak-函数" class="headerlink" title="netpollBreak 函数"></a>netpollBreak 函数</h2><p>netpollBreak函数的功能比较简单，但实现比较有意思。它和netpoll函数通过变量netpollWakeSig进行交互，由于在不同的goroutine中，所以对于该变量的操作都是原则操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// netpollBreak interrupts an epollwait.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.Cas(&amp;netpollWakeSig, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> b <span class="type">byte</span></span><br><span class="line">      n := write(netpollBreakWr, unsafe.Pointer(&amp;b), <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> n == -_EINTR &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> n == -_EAGAIN &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: netpollBreak write failed with&quot;</span>, -n)</span><br><span class="line">      throw(<span class="string">&quot;runtime: netpollBreak write failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll-runtime-pollOpen-函数"><a href="#poll-runtime-pollOpen-函数" class="headerlink" title="poll_runtime_pollOpen 函数"></a>poll_runtime_pollOpen 函数</h2><p>poll_runtime_pollOpen 的逻辑分为三块:</p>
<ol>
<li>给 pollDesc 分配内存</li>
<li>初始化 pollDesc 对象</li>
<li>借助于 netpollopen 注册epoll监听(netpollopen在linux下是 epoll_ctl)</li>
<li>返回 pollDesc 对象</li>
</ol>
<p>poll_runtime_pollOpen函数的实现位于 runtime/netpoll.go 中, 主要逻辑如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> (*pollDesc, <span class="type">int</span>) &#123;</span><br><span class="line">  pd := pollcache.alloc()</span><br><span class="line">  lock(&amp;pd.lock)</span><br><span class="line">  wg := pd.wg.Load()</span><br><span class="line">  <span class="keyword">if</span> wg != <span class="number">0</span> &amp;&amp; wg != pdReady &#123;</span><br><span class="line">    throw(<span class="string">&quot;runtime: blocked write on free polldesc&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  rg := pd.rg.Load()</span><br><span class="line">  <span class="keyword">if</span> rg != <span class="number">0</span> &amp;&amp; rg != pdReady &#123;</span><br><span class="line">    throw(<span class="string">&quot;runtime: blocked read on free polldesc&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  pd.fd = fd</span><br><span class="line">  <span class="comment">// ... 省略部分初始化逻辑</span></span><br><span class="line">  unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">  errno := netpollopen(fd, pd)</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    pollcache.free(pd)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="type">int</span>(errno)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pd, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于net/netpoll_epoll.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> ev epollevent</span><br><span class="line">  ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">  *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">  <span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll-runtime-pollWait-函数"><a href="#poll-runtime-pollWait-函数" class="headerlink" title="poll_runtime_pollWait 函数"></a>poll_runtime_pollWait 函数</h2><p>poll_runtime_pollWait 函数只是对 netpollblock 函数的封装，增加了容错。值得注意的是，该函数不是runtime触发的，而是用户程序触发的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  errcode := netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">  <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">    <span class="keyword">return</span> errcode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// As for now only Solaris, illumos, and AIX use level-triggered IO.</span></span><br><span class="line">  <span class="keyword">if</span> GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;aix&quot;</span> &#123;</span><br><span class="line">    netpollarm(pd, mode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">    errcode = netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">    <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">      <span class="keyword">return</span> errcode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Can happen if timeout has fired and unblocked us,</span></span><br><span class="line">    <span class="comment">// but before we had a chance to run, timeout has been reset.</span></span><br><span class="line">    <span class="comment">// Pretend it has not happened and retry.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们看下用户程序如何触发 poll_runtime_xxx 系列的函数。首先，套接字分为两类：LISTEN套接字(Server套接字) 和 ESTABLISHED套接字(TCPConn)；</p>
<ul>
<li>LISTEN 套接字通过系统调用 socket/bind/listen 去生成；</li>
<li>ESTABLISHED 套接字通过系统调用 accept 去生成；</li>
</ul>
<h2 id="LISTEN套接字-Server套接字"><a href="#LISTEN套接字-Server套接字" class="headerlink" title="LISTEN套接字(Server套接字)"></a>LISTEN套接字(Server套接字)</h2><p>从http server的角度来看，LISTEN套接字注册epoll监听的链路如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> ListenAndServe() <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// net/dial.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="type">string</span>)</span></span> (Listener, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> lc ListenConfig</span><br><span class="line">  <span class="keyword">return</span> lc.Listen(context.Background(), network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/dial.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lc *ListenConfig)</span></span> Listen(ctx context.Context, network, address <span class="type">string</span>) (Listener, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/tcpsock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sysListener)</span></span> listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/ipsock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internetSocket</span><span class="params">(ctx context.Context, net <span class="type">string</span>, laddr, raddr sockaddr, sotype, proto <span class="type">int</span>, mode <span class="type">string</span>, ctrlFn <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>, syscall.RawConn)</span></span> <span class="type">error</span>) (fd *netFD, err <span class="type">error</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// net/sock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="type">string</span>, family, sotype, proto <span class="type">int</span>, ipv6only <span class="type">bool</span>, laddr, raddr sockaddr, ctrlFn <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>, syscall.RawConn)</span></span> <span class="type">error</span>) (fd *netFD, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/sock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> listenStream(laddr sockaddr, backlog <span class="type">int</span>, ctrlFn <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, <span class="type">string</span>, syscall.RawConn)</span></span> <span class="type">error</span>)</span><br><span class="line">  <span class="keyword">if</span> err = fd.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> init() <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// fd.pfd 类型是 poll.FD</span></span><br><span class="line">  <span class="keyword">return</span> fd.pfd.Init(fd.net, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Init(net <span class="type">string</span>, pollable <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// We don&#x27;t actually care about the various network types.</span></span><br><span class="line">  <span class="keyword">if</span> net == <span class="string">&quot;file&quot;</span> &#123;</span><br><span class="line">    fd.isFile = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> !pollable &#123;</span><br><span class="line">    fd.isBlocking = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  err := fd.pd.init(fd)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// If we could not initialize the runtime poller,</span></span><br><span class="line">    <span class="comment">// assume we are using blocking mode.</span></span><br><span class="line">    fd.isBlocking = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_poll_runtime.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">  serverInit.Do(runtime_pollServerInit)</span><br><span class="line">  ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">  &#125;</span><br><span class="line">  pd.runtimeCtx = ctx</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ESTABLISHED套接字-TCPConn"><a href="#ESTABLISHED套接字-TCPConn" class="headerlink" title="ESTABLISHED套接字(TCPConn)"></a>ESTABLISHED套接字(TCPConn)</h2><p>http server accept 新的tcp conn</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    rw, err := l.Accept()</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/tcpsock.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TCPListener)</span></span> Accept() (Conn, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *TCPListener)</span></span> accept() (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line">  fd, err := ln.fd.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/fd_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> accept() (netfd *netFD, err <span class="type">error</span>) &#123;</span><br><span class="line">  d, rsa, errcall, err := fd.pfd.Accept()</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  <span class="keyword">if</span> err = netfd.init(); err != <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Init(net <span class="type">string</span>, pollable <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_poll_runtime.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<h2 id="关于-net-netFD-struct"><a href="#关于-net-netFD-struct" class="headerlink" title="关于 net.netFD struct"></a>关于 net.netFD struct</h2><p>netFD是对套接字(网络文件描述符)的封装。对于Server套接字而言，可以通过accept方法从Server套接字(LISTEN套接字)获取新的TCP连接(或ESTABLISHED套接字)。Linux的accept系统调用返回的ESTABLISHED套接字是一个int值，通过 newFD 和 init 函数将其封装为一个完整的 netFD结构，后面会被封装为一个net.TCPConn。</p>
<p>对于操作系统而言，LISTEN套接字和ESTABLISHED套接字都只是一个int类型的文件描述符，没有本质区别。系统调用accept和read都是从套接字读取数据，所以epoll里会放到一个batch里去监听。</p>
<p>这是 netFD 的定义和accept方法的实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Network file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">  pfd poll.FD</span><br><span class="line"></span><br><span class="line">  <span class="comment">// immutable until Close</span></span><br><span class="line">  family      <span class="type">int</span></span><br><span class="line">  sotype      <span class="type">int</span></span><br><span class="line">  isConnected <span class="type">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">  net         <span class="type">string</span></span><br><span class="line">  laddr       Addr</span><br><span class="line">  raddr       Addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> accept() (netfd *netFD, err <span class="type">error</span>) &#123;</span><br><span class="line">  d, rsa, errcall, err := fd.pfd.Accept()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> errcall != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      err = wrapSyscallError(errcall, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    poll.CloseFunc(d)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err = netfd.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    netfd.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  lsa, _ := syscall.Getsockname(netfd.pfd.Sysfd)</span><br><span class="line">  netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))</span><br><span class="line">  <span class="keyword">return</span> netfd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>net.netFD 依赖 poll.FD 实现poll功能。区别正如名字所展示，net.netFD是封装了网络相关的功能，而 poll.FD是更为通用的FD，封装了文件描述符上能进行的操作。其定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FD is a file descriptor. The net and os packages use this type as a</span></span><br><span class="line"><span class="comment">// field of a larger type representing a network connection or OS file.</span></span><br><span class="line"><span class="keyword">type</span> FD <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// Lock sysfd and serialize access to Read and Write methods.</span></span><br><span class="line">  fdmu fdMutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">// System file descriptor. Immutable until Close.</span></span><br><span class="line">  Sysfd <span class="type">int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// I/O poller.</span></span><br><span class="line">  pd pollDesc</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Writev cache.</span></span><br><span class="line">  iovecs *[]syscall.Iovec</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Semaphore signaled when file is closed.</span></span><br><span class="line">  csema <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Non-zero if this file has been set to blocking mode.</span></span><br><span class="line">  isBlocking <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether this is a streaming descriptor, as opposed to a</span></span><br><span class="line">  <span class="comment">// packet-based descriptor like a UDP socket. Immutable.</span></span><br><span class="line">  IsStream <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether a zero byte read indicates EOF. This is false for a</span></span><br><span class="line">  <span class="comment">// message based socket connection.</span></span><br><span class="line">  ZeroReadIsEOF <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether this is a file rather than a network socket.</span></span><br><span class="line">  isFile <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll.FD 依赖 poll.pollDesc 实现poll功能。poll.pollDesc 实现了 IO polling 的功能。poll.pollDesc 有一系列的方法，比如 init、wait、close、prepare 等都是对 runtime_pollXXX 函数系列的封装，下面诗pollDesc的部分逻辑:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">  runtimeCtx <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverInit sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">  serverInit.Do(runtime_pollServerInit)</span><br><span class="line">  ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">  &#125;</span><br><span class="line">  pd.runtimeCtx = ctx</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术类</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>《杀虫》若水</title>
    <url>/posts/ae350edf.html</url>
    <content><![CDATA[<p>初夏的天气已经使我心烦意乱</p>
<p>休憩了太久</p>
<p>思索几番，不得真谛</p>
<p>一只弱小的虫，趴在闪烁的悬崖处</p>
<p>试探着，一个无情之人的善念</p>
<p>是否会给它一个了断</p>
<p>先是假装的挣扎</p>
<p>再来几个诱惑性的旋转舞蹈</p>
<p>绕过睫毛，似乎还有话要说</p>
<p>絮絮叨叨，总也说不完</p>
<p>终于——</p>
<p>食指和拇指不耐烦地捏住了这可怜的虫</p>
<p>稍一用力</p>
<p>碾碎了一个有骨气的灵魂</p>
<p>柔软的翅膀多了几分铁骨铮铮</p>
<p>一手扔到地上</p>
<p>闭上眼</p>
<p>进了梦境</p>
]]></content>
      <categories>
        <category>网文</category>
        <category>小说</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo的npm依赖环境以及博客部署备忘录</title>
    <url>/posts/28dcdc4c.html</url>
    <content><![CDATA[<h3 id="pug-以及-stylus-的渲染器"><a href="#pug-以及-stylus-的渲染器" class="headerlink" title="pug 以及 stylus 的渲染器"></a>pug 以及 stylus 的渲染器</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer-pug</span> hexo<span class="literal">-renderer-stylus</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<h3 id="butterfly开启本地搜索"><a href="#butterfly开启本地搜索" class="headerlink" title="butterfly开启本地搜索"></a>butterfly开启本地搜索</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator-search</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<h3 id="开启hexo-abbrlink文章链接"><a href="#开启hexo-abbrlink文章链接" class="headerlink" title="开启hexo-abbrlink文章链接"></a>开启hexo-abbrlink文章链接</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-abbrlink</span> <span class="literal">--save</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span>     <span class="comment"># 将原来文章的地址修改为这个</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 并添加如下配置：</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment">#support dec(default) and hex</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment">#(true)Process draft,(false)Do not process draft. false(default) </span></span><br></pre></td></tr></table></figure>

<h3 id="部署必备插件"><a href="#部署必备插件" class="headerlink" title="部署必备插件"></a>部署必备插件</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-deployer-git</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<h3 id="开启百度站长主动推送文章链接"><a href="#开启百度站长主动推送文章链接" class="headerlink" title="开启百度站长主动推送文章链接"></a>开启百度站长主动推送文章链接</h3><p>安装依赖</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install hexo<span class="literal">-baidu-url-submit</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure>

<p>修改配置文件<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置百度主动推送</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">200</span>  <span class="comment">#比如200，代表提交最新的200个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">www.kimtoli.com</span> <span class="comment"># 在百度站长平台中注册的域名，这个改为你自己的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">your_token</span> <span class="comment"># 百度站长token字段</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 新链接会保存在此文本文档里（文本文件的文件名）</span></span><br></pre></td></tr></table></figure>

<p>加入新的deploy项</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:XXX/XXX.github.io.git</span>  <span class="comment"># Github地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span>  <span class="comment"># 这一行是新增的配置</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术类</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>一些很有用的JavaScript代码</title>
    <url>/posts/bbf49370.html</url>
    <content><![CDATA[<h3 id="获取浏览器cookie值"><a href="#获取浏览器cookie值" class="headerlink" title="获取浏览器cookie值"></a>获取浏览器cookie值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cookie = name =<span class="string">`; <span class="subst">$&#123;<span class="variable language_">document</span>.cookie&#125;</span>`</span>.<span class="title function_">split</span>(<span class="string">`; <span class="subst">$&#123;name&#125;</span>=`</span>).<span class="title function_">pop</span>().<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>).<span class="title function_">shift</span>();</span><br><span class="line"><span class="title function_">cookie</span>(<span class="string">&#x27;_ga&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="将RGB转换为16进制"><a href="#将RGB转换为16进制" class="headerlink" title="将RGB转换为16进制"></a>将RGB转换为16进制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">rgbToHex</span> = (<span class="params">r, g, b</span>) =&gt;</span><br><span class="line"><span class="string">&quot;#&quot;</span> + ((<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + (r &lt;&lt; <span class="number">16</span>) + (g &lt;&lt; <span class="number">8</span>) + b).<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">rgbToHex</span>(<span class="number">0</span>, <span class="number">51</span>, <span class="number">255</span>);</span><br></pre></td></tr></table></figure>

<h3 id="复制到剪切板"><a href="#复制到剪切板" class="headerlink" title="复制到剪切板"></a>复制到剪切板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> copyToClipboard = (text) =navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(text);</span><br><span class="line"><span class="title function_">copyToClipboard</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="检查日期是否有效"><a href="#检查日期是否有效" class="headerlink" title="检查日期是否有效"></a>检查日期是否有效</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDateValid = (...val) =!<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(...val).<span class="title function_">valueOf</span>());</span><br><span class="line"><span class="title function_">isDateValid</span>(<span class="string">&quot;December 17, 1995 03:24:00&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>找出一年中的某一天（即给出一个日期，程序给出属于本年的第多少天）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dayOfYear</span> = (<span class="params">date</span>) =&gt;</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>((date - <span class="keyword">new</span> <span class="title class_">Date</span>(date.<span class="title function_">getFullYear</span>(), <span class="number">0</span>, <span class="number">0</span>)) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">dayOfYear</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// Result: 272</span></span><br></pre></td></tr></table></figure>

<h3 id="将字符串首字母大写"><a href="#将字符串首字母大写" class="headerlink" title="将字符串首字母大写"></a>将字符串首字母大写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> capitalize = str =str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">capitalize</span>(<span class="string">&quot;follow for more&quot;</span>)</span><br><span class="line"><span class="comment">// Result: Follow for more</span></span><br></pre></td></tr></table></figure>

<h3 id="计算两个日期之间相差的天数"><a href="#计算两个日期之间相差的天数" class="headerlink" title="计算两个日期之间相差的天数"></a>计算两个日期之间相差的天数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dayDif = (date1, date2) =<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(date1.<span class="title function_">getTime</span>() - date2.<span class="title function_">getTime</span>()) / <span class="number">86400000</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">dayDif</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2020-10-21&quot;</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2021-10-22&quot;</span>))</span><br><span class="line"><span class="comment">// Result: 366</span></span><br></pre></td></tr></table></figure>

<h3 id="清除所有cookie"><a href="#清除所有cookie" class="headerlink" title="清除所有cookie"></a>清除所有cookie</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clearCookies = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>).<span class="title function_">forEach</span>(cookie =<span class="variable language_">document</span>.<span class="property">cookie</span> = cookie.<span class="title function_">replace</span>(<span class="regexp">/^ +/</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/=.\*/</span>, <span class="string">`=;expires=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>).toUTCString()&#125;</span>;path=/`</span>));</span><br></pre></td></tr></table></figure>

<h3 id="生成随机16进制"><a href="#生成随机16进制" class="headerlink" title="生成随机16进制"></a>生成随机16进制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> randomHex = () =<span class="string">`#<span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">0xffffff</span>).toString(<span class="number">16</span>).padEnd(<span class="number">6</span>, <span class="string">&quot;0&quot;</span>)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">randomHex</span>());</span><br><span class="line"><span class="comment">// Result: #92b008</span></span><br></pre></td></tr></table></figure>

<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> removeDuplicates = (arr) =[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">removeDuplicates</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>]));</span><br><span class="line"><span class="comment">// Result: [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="从URL中获取查询参数"><a href="#从URL中获取查询参数" class="headerlink" title="从URL中获取查询参数"></a>从URL中获取查询参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getParameters = (<span class="variable constant_">URL</span>) =&#123;</span><br><span class="line"><span class="variable constant_">URL</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;&#x27;</span> + <span class="built_in">decodeURI</span>(<span class="variable constant_">URL</span>.<span class="title function_">split</span>(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>]).<span class="title function_">replace</span>(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;\\&quot;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&quot;,&quot;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/=/g</span>, <span class="string">&#x27;&quot;:&quot;&#x27;</span>) +<span class="string">&#x27;&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable constant_">URL</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getParameters</span>(<span class="variable language_">window</span>.<span class="property">location</span>)</span><br><span class="line"><span class="comment">// Result: &#123; search : &quot;easy&quot;, page : 3 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="从日期中获取“时分秒”格式的时间"><a href="#从日期中获取“时分秒”格式的时间" class="headerlink" title="从日期中获取“时分秒”格式的时间"></a>从日期中获取“时分秒”格式的时间</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timeFromDate = date =date.<span class="title function_">toTimeString</span>().<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">timeFromDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2021</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>)));</span><br><span class="line"><span class="comment">// Result: &quot;17:30:00&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="确认奇偶数"><a href="#确认奇偶数" class="headerlink" title="确认奇偶数"></a>确认奇偶数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过数据%2来判断并返回布尔类型</span></span><br><span class="line"><span class="keyword">const</span> isEven = num =num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEven</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// Result: True</span></span><br></pre></td></tr></table></figure>

<h3 id="回到顶部（适用于网页右下角快捷返回功能）"><a href="#回到顶部（适用于网页右下角快捷返回功能）" class="headerlink" title="回到顶部（适用于网页右下角快捷返回功能）"></a>回到顶部（适用于网页右下角快捷返回功能）</h3><p>//通过将x、y设置为0来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> goToTop = () =<span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="title function_">goToTop</span>();</span><br></pre></td></tr></table></figure>

<h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverse = str =str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="title function_">reverse</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="comment">// Result: &#x27;dlrow olleh&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="检查数组是否为空"><a href="#检查数组是否为空" class="headerlink" title="检查数组是否为空"></a>检查数组是否为空</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过对数组长度判断来确定是否为空</span></span><br><span class="line"><span class="keyword">const</span> isNotEmpty = arr =<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) &amp;&amp; arr.<span class="property">length</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isNotEmpty</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// Result: true</span></span><br></pre></td></tr></table></figure>

<h3 id="获取用户选定的文本"><a href="#获取用户选定的文本" class="headerlink" title="获取用户选定的文本"></a>获取用户选定的文本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getSelectedText = () =<span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSelectedText</span>();</span><br></pre></td></tr></table></figure>

<h3 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffleArray = (arr) =arr.<span class="title function_">sort</span>(() =<span class="number">0.5</span> - <span class="title class_">Math</span>.<span class="title function_">random</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">shuffleArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br><span class="line"><span class="comment">// Result: [ 1, 4, 3, 2 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="检查用户是否处于暗模式"><a href="#检查用户是否处于暗模式" class="headerlink" title="检查用户是否处于暗模式"></a>检查用户是否处于暗模式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDarkMode = <span class="variable language_">window</span>.<span class="property">matchMedia</span> &amp;&amp; <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>).<span class="property">matches</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isDarkMode) <span class="comment">// Result: True or False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术类</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>我以我满门名誉，用命换了和将军的一纸婚书，却死在他给我安排的牢笼里</title>
    <url>/posts/bdf69bea.html</url>
    <content><![CDATA[<p>【被囚禁的金丝雀】<br>昏暗没有一丝光亮的囚牢里，关押着一只不停挣扎的金丝雀。<br>一盘冷眼旁观的男子负手而立，任凭那只金丝雀叫破了嗓子也不为所动。<br>我一身冷汗的从地上爬起来，又梦到这个场景了。<br>现如今我被池鱼关在这暗无天日的地牢已经数月有余。<br>每天都重复梦见囚鸟惨烈的悲剧，忐忑度日。<br>我听着地面上传来的锣鼓喧天声，猜想他应是今日成婚。<br>他成婚以后，有了自己心爱的人，就会对我失去兴趣从而忘却我这个人吧。<br>不知那灯火通明处是谁在与谁共度良宵，反观我周身黑灯瞎火的，谁又来诉说一分悲凉<br>我是赤羽军唯一的主帅，子承父业一生都在守卫顾家的江山。<br>却在大破敌军国都后被我效忠的皇帝和心爱的弟弟联合陷害，落得个虎困牢笼之苦。<br>玄铁黑链随我的动作磕磕碰碰的发出一丝丝凄凉声。<br>我很早之前便猜想过自己的结局，生老病死从来不可避免，可我没想到我最后既然会死在自己一直疼爱的人手上。<br>与其等他来屈辱的了结我，我更喜欢命运掌握在自己手上的感觉。<br>我拿起今早送饭的小厮不小心打碎的碗片，它被我藏在两腿之间才没有被人发现收走。<br>也给了我一个解脱的机会。<br>我生而为帅，只可战败而死，不可为囚而亡。<br>锣鼓声好像停了，我的意识也随鼓声逐渐模糊。<br>将死之际，我似乎看见那年海棠微雨，十几岁的少年郎在满天星辰下和我招手。<br>原本那么要好的两人，不知何时这般陌路。<br>我的意识升上了半空，手上铁链的重量感也随之减轻，心里这长舒了一口气。<br>目光再看向地面血污中的肉身时，我竟生出了几分恍惚，那人安静的躺着，手中紧紧捏着一纸婚书。<br>日期也是元月二八。<br>是的，死之前，我怀里抱着的，是池鱼亲笔写给我的婚书。<br>我的弟弟。<br>池鱼看起来像无辜温顺的小白兔，实际上是个心狠手辣，杀伐果断的猛虎。<br>他不擅武艺，做不到刀剑伤人，可自古要人性命的，还有那口诛笔伐的唾沫。<br>我依稀记得我战胜归来，等来的不是道贺，而是铺天盖地的谩骂。<br>我质问他，为何要将我对他的感情公之于众，为何要将它说的那么不堪。<br>他高高在上藐视着我，他说，我看到的一切都只是我的痴心妄想，我在乎的感情也不过是杀死我自己的一把刀，他一直在利用我。<br>他将我推向风口浪尖，让世人质疑，猜忌我，只因我的一句想与他成婚，只因他与我皆是男子。<br>可先与我谈及秦晋之好的，是他池鱼。<br>他就这样毁了我的一生，甚至于，在我一无所有之时，暗自囚禁我。<br>可我不认，我不做这金丝雀。</p>
<p>【记忆里的池鱼】<br>我在地牢角落呆呆的等了几个时辰，也没见到黑白双煞来接我走。<br>却不想等来了池鱼。<br>他停在地牢门口背着身，迟迟没有下一步动作，他并不想见我。<br>良久他才吐出一口浊气，似乎在挣扎什么。<br>“顾渊，你是否听得到？”<br>我听见池鱼闷闷的声音，可是我已经死了，回答不了他。<br>“你可恨我？”<br>我以为自己死后会毫无波澜的听他问起我恨不恨，可当这话在我耳边响起时，我还是激动万分。<br>可我说不出口。<br>“今天下雪了，我带你出去看看好不好。”<br>没得到我的回音，池鱼不知所措的捏紧了衣角。<br>这不像他，他为何要装的如此深情，明明，他很讨厌这段感情。<br>我悄悄凑到他身前，盯着他笼在黑影里的脸。<br>他不是今日成亲么，为何没有穿喜服，为何不去与新娘春宵一刻，却要半夜行至我这肮脏的地牢。<br>我和池鱼从小一块长大，他是我爹上山打猎从寒冬腊月里捡回来的。<br>我爹说，他衣衫褴褛，却在冬日里哭声嘹亮，所以给我捡回来做弟弟，让我有个伴。<br>我爹看他是个好苗子，有意培养他，时常教他武学之道，可池鱼学不来，他连剑都握不稳。<br>可他七岁会作诗，八岁便能将大道侃侃而谈，诸如此类，数不胜数。<br>就这般，池鱼文采斐然，我武艺超群，世人艳羡我爹，养了一对双子星。<br>我爹也乐呵呵的，笑的整个人年轻了十几岁。<br>可他没能笑着看他养出来的双子星名扬天下。<br>在我十七岁那年，我爹他战死沙场。<br>我和池鱼知晓我爹班师回朝的日子，那天早早的便等在城墙外。<br>烈马破开皇城，直逼天子宫门。<br>我还疑惑有何事这般火急，下一秒便看见了紧跟在后面挂满白绫的军队。<br>我爹被敌军设的圈套陷害了，可他也只是想多救一个自己的将士，不料那将士早已叛变。<br>我听后稳不住自己的步子，倒在池鱼怀里晕了过去。<br>待我再醒来，池鱼已经在朝堂跪了一天一夜，祈求天子能派兵绞杀敌军和叛国贼。<br>可朝堂之上无一人敢出言。<br>我爹一死，一时竟没有武将敢迎战。<br>一开始天子还会客套的打发池鱼，说此事必有蹊跷，需得从长计议，见劝不动池鱼，便也任由他跪着了。<br>我赶至池鱼身边，派人将他拉回去休息，代替他跪在了那个位置。<br>少年天子见是我来，恼怒的推开门，将明黄圣旨丢在我身上。<br>“顾渊，你也要来逼朕是不是？给你，都给你，朕给你写，你要谁去出征替你父亲讨公道，朕满足你。”<br>我沉默不语，少年天子胸膛剧烈起伏着。<br>“臣恳请陛下，让臣挂帅。”<br>殿内静的只剩我和他的呼吸声，良久，天子才捡起掉落我脚边的圣旨，在挂帅前那一处空白的地方写下我的名字。<br>他长叹一声，我冲他笑了笑，领着圣旨走了。<br>没等池鱼醒来，我便日夜兼程去往八百里外的毫州。<br>我只带了一千精兵，劫了敌军的粮草，夜半一把火烧了他们歇脚的地方。<br>火舌吞吐着，我在火光中看见了我爹。<br>第一缕曙光照在身上时，杀声震天，我执剑砍下一个又一个敌军的头颅，身上已分不清是谁的血。<br>在剑身穿透敌军首领的胸膛，其余散军因为首领被杀而纷纷溃散后，我才扛不住单膝跪在染满血的泥地里。<br>吐出嘴里不停涌上来的血，眼前一阵天悬地转，耳鸣不断。<br>我以为要死了的时候，看见池鱼脸色煞白的将我拥入怀中。<br>“小鱼，哥哥身上脏。”<br>池鱼将我拥得更紧了，似乎要将我融入他的血肉之躯中。<br>“我不嫌你。”<br>是的，池鱼从来不会嫌我脏。<br>那个时候，我刚刚丧父，对池鱼这个唯一的在世亲人格外依赖。<br>他无微不至的照顾战后应激的我，那时我便觉得我对于他来说或许也是不一样的。<br>我看了一眼躺在血污里的肉身，脏吗？应该是的，不然池鱼怎么会不想进去里面看我一眼呢。<br>只要他往后看一眼，就能知道我已微凉的尸体，可他不会，他连看我一眼都觉得为难。<br>我记得很久以前，池鱼从来不会嫌我脏的。</p>
<p>【一颗苦味的糖】<br>思绪倒回，我轻叹了一口气。<br>池鱼见我不理他，泄气般坐在地牢门口，我和他并排坐着，只可惜他看不见我的灵魂。<br>“顾渊，我前几天去了一趟杭州。”<br>我垂目想了想，池鱼去杭州，是去做什么呢？<br>是那里的布匹好看，去给他的新娘子缝制婚服么？<br>还是那边的点心好吃，买喜糖去了。<br>我皱起眉头，在池鱼身上摸索起来，怎么买了喜糖也不给我这个做哥哥的送一点，当真一点也不顾及儿时情谊。<br>或许对他来说，那儿时的情谊，才是捆绑他的枷锁。<br>他依旧自顾自的看着某一处，没有发觉我的动作。<br>我由着自己的小性子，反正我已经死了，再任性一点也无妨。<br>可我摸不到池鱼，枯瘦的手指从他身体身上穿透而出，也对，我现在没有实体。<br>池鱼叹息一声，从腰带里掏出一块梨花酥。<br>我顺着他的手掌尝了两口，苦涩的很，我呸呸两声连忙吐掉。<br>我记得我以前最爱吃梨花酥了，怎么现在吃起来这么苦呢。<br>是因为这是池鱼的喜糖吗？<br>我喜甜口，以前身上总是会带着几颗糖，池鱼明明最讨厌甜味，却不怨其烦的陪我品尝了世间饴糖。<br>从我爹去世后，很少有人记得我爱吃甜食，我也时常奔波在军营和练武场，这个小习惯便淡忘了。<br>可每次池鱼来找我时，都会塞给我一大把口味各式的糖。<br>我问他为何如此，他总倔强的说是他买多了吃不完的，秉承着不能浪费，让我替他解决掉。<br>直到我意外发现那是他跑遍各地州县，买回五颜六色的饴糖，偷偷一个人尝鲜，然后把我会喜欢的留下来。<br>为此，他被腻的好几天吃不下饭。<br>我不再看此时池鱼手里的那块梨花酥，或许是人死了之后味觉变了，池鱼给我的糖必然不会是苦的。<br>就算是他的喜糖，他要送给我，也该是千挑万选过的。<br>他再不喜欢我，也记得我喜甜口。<br>池鱼将那块梨花酥送入口中，嚼着嚼着却落了泪，我惊慌失措的去替他擦拭，可那泪水径直略过我的手指，掉落在地上。<br>“顾渊，糖好苦啊。”<br>我听见池鱼说。<br>他说好苦，他在哭。<br>在我还未成为名扬天下的一军主帅前，也曾吃过一颗苦到心间的糖。<br>我爹从小便教我，练武之人不得有极端之心，任何事情都讲究个理。<br>我从小对我爹的话奉为圭璧，也坚信这是为人处事的准则。<br>可当我亲眼看见一城人的性命被一个理字活生生害死时，我便从心底里打破了这条束缚我的准则。<br>毫州一战后，蛮夷忌惮顾家还有后备之才不敢轻举妄动，因此消停了几日。<br>或许是探查了两天，发觉毫州短时间没有兵力再承受一战，野心勃勃的他们当然不愿意放过这个重创我们夏国的机会。<br>可两场战斗下来，朝堂亏损严重。<br>将士们连休养生息都没来得及，便又披挂上阵。<br>我尚未真正上过战场，能打退他们已是凭借那一腔为父报仇的热血，再开城门迎战，也有些棘手起来。<br>我自认武学天下人少有胜过我的，也耐不住蛮夷的车轮战术，几次负伤。<br>八百里加急的请兵书往皇城送了一封又一封，没有一封有回音，我知道，天子不打算保亳州了。<br>可我不愿，我不愿看这一城人的性命死在蛮夷的刀下，成为被国家放弃的孤魂野鬼。</p>
<p><strong>———– 全文内容使用UC浏览器搜索【被将军大人圈养的小白兔弟弟】 ———–</strong></p>
]]></content>
      <categories>
        <category>网文</category>
        <category>小说</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。</title>
    <url>/posts/fcce4138.html</url>
    <content><![CDATA[<h3 id="腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。"><a href="#腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。" class="headerlink" title="腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。"></a>腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。</h3><p>4月7日，腾讯视频与抖音集团宣布达成合作，双方将围绕长短视频联动推广、短视频衍生创作开展合作。腾讯视频将向抖音授权其享有信息网络传播权及转授权权利的长视频。此外，腾讯视频与抖音还明确了短视频衍生创作的方式、发布规则，共同促进短视频的创作、传播。</p>
<p>这次合作，也被外界视为“世纪大和解”。此前，腾讯和抖音曾因版权问题多次对簿公堂，也曾在公开场合互相炮轰。如今双方的握手言和，意味着双方在长短视频创作领域找到了利益共通点。在短视频的直接交锋之外，腾讯的长视频资源也可以以版权授权的形式，授予它的直接竞争对手。</p>
<p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102130.jpg" alt="腾讯和抖音合作"></p>
<h3 id="腾讯自营短视频产品的始末"><a href="#腾讯自营短视频产品的始末" class="headerlink" title="腾讯自营短视频产品的始末"></a>腾讯自营短视频产品的始末</h3><p>值得一提的是，腾讯其实是国内最早布局短视频的互联网公司之一，早在2013年，就上线了微视，但当时的战略，不过是对标海外产品的进行新产品尝试，并没有在战略上重视，由于总办对其市场化的误判，最后在2015年开始实质上放弃。</p>
<p>快手和抖音火爆后，腾讯希望重新回到这条赛道上来，这几年，腾讯帝国内部各路诸侯先后发布了哈皮、yoo视频等十余款短视频APP，最后基本都以失败告终。</p>
<p>2017年，以抖音和快手为代表的短视频持续高歌猛进，腾讯开始复活微视，甚至提到了“战略级”。但微视这款产品似乎受到了诅咒，内部资源和组织难以顺畅打通，发力艰难，在外部，则一直不被主流圈子看好，现在依然处在艰难爬坡的状态，目前看只能作为防御性产品拖住竞争对手。</p>
<p>也是在这个时候，腾讯微视的小2联系到了我，顺利入住的微视MCN合作机构，作为集团“战略级”产品，扶持当然是不能少了，腾讯集团公司花了巨款砸在了内容补贴上面，补贴方式为cpm结算，实不相瞒。。我在刚开始做的时候，最风口的时刻，单微视这一个项目单月拿了60多个W的流水（包含达人50%的分成，以及将近4万块的增值税），流水月入百万的MCN机构老板我微信朋友圈也加着几个，只能说腾讯在力度方面真的狠上了。。。。</p>
<p>但是，投入巨大资源的微视在2019年并没有完成4000万DAU的目标，从腾讯PCG负责人任宇昕在年会上定2020年新目标为5000万DAU的目标来看，2019年的目标是远远未达标的。当然，微视最大的问题，不是缺增长，而是缺留存，快手与抖音的留存都在80%左右，而微视仅在43%上下徘徊，这就非常尴尬。在2020年，它大概率会被认定为一款只有防守价值的产品。</p>
<p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102045.jpg" alt="腾讯微视"></p>
<h3 id="曾多次对簿公堂，创始人曾朋友圈“互怼”"><a href="#曾多次对簿公堂，创始人曾朋友圈“互怼”" class="headerlink" title="曾多次对簿公堂，创始人曾朋友圈“互怼”"></a><strong>曾多次对簿公堂，创始人曾朋友圈“互怼”</strong></h3><p>2018年5月，抖音成为全球第一季度App Store下载量最高应用时，字节跳动创始人张一鸣在朋友圈写下这样一句话，“微信的借口封杀，微视的抄袭搬运，挡不住抖音的步伐。”腾讯创始人马化腾随即在下方回应称：“可以理解为诽谤。”</p>
<p>两名互联网大佬朋友圈公开互怼背后，是腾讯和字节之间“头腾大战”持续升级的一个缩影。特别是在短视频领域，当时占据杆位的抖音，对迟迟未能形成突破的腾讯，形成巨大压力。版权，成了双方交锋的一个发泄口。</p>
<p>公开资料显示，腾讯和抖音之间就视频版权有过多次纠纷。去年10月26日，西安市中级人民法院就《云南虫谷》案作出一审判决。法院认为，抖音平台上有大量用户对涉案作品实施侵权行为，需赔偿腾讯经济损失及合理费用3240余万元，刷新了全国法院网络影视版权案件赔偿纪录。</p>
<p>公开资料显示，《云南虫谷》为腾讯旗下企鹅影视出品的悬疑冒险网络剧，改编自天下霸唱小说《鬼吹灯之云南虫谷》。</p>
<p>2021年6月，腾讯向重庆一中院起诉，认为抖音平台内的用户上传内容侵害了《斗罗大陆》著作权，要求法院判令抖音赔偿经济损失并合理支出共计6160万元，此后又将索赔金额从6160万元提高到8亿元。</p>
<p>同年，字节跳动也在重庆市第一中级法院起诉腾讯，原因是腾讯视频上存在大量涉及电视剧《亮剑》的侵权视频，要求法院判令腾讯删除侵权视频、发布声明消除影响，并赔偿经济损失1000万元。</p>
<p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102155.jpg" alt="腾讯VS抖音"></p>
<h3 id="视频号和抖音的产品整合？"><a href="#视频号和抖音的产品整合？" class="headerlink" title="视频号和抖音的产品整合？"></a><strong>视频号和抖音的产品整合？</strong></h3><p>微信视频号的崛起，应该也为腾讯视频对外版权合作提供了更多底气。</p>
<p>眼下，视频号已成微信业务中当之无愧的“C位”。据腾讯最新财报，微信视频号的使用时长已达到朋友圈的1.2倍。数据显示，去年第四季度，视频号季度收入超过10亿，去年视频号直播带货销售增长800%，累计有收入的作者数对比2021年增长2.64倍。</p>
<p>腾讯CEO马化腾也曾在内部员工大会上的讲话中提到，微信事业群最亮眼的业务是视频号，基本上是全公司的希望。</p>
<p>不过，腾讯高管也在财报后的电话会议中坦言，相比竞争对手的短视频服务，视频号目前的广告数量仍处于相对落后的水平。相比抖音，腾讯视频号也尚未孵化出头部创作者。</p>
<p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102213.jpg" alt="视频号"></p>
<h3 id="长短视频平台大和解"><a href="#长短视频平台大和解" class="headerlink" title="长短视频平台大和解"></a><strong>长短视频平台大和解</strong></h3><p>可见的是，这并不是长短视频平台的首次牵手。去年7月19日，抖音集团和爱奇艺宣布达成合作。爱奇艺将向抖音集团授权其内容资产中拥有信息网络传播权及转授权的长视频内容，用于短视频创作，双方也对解说、混剪、拆条等短视频二创形态做出具体约定。</p>
<p>去年6月30日，快手曾宣布与乐视视频达成二创相关授权合作。这意味着快手创作者可以对乐视视频独家自制版权作品进行剪辑及二次创作，并发布在快手平台内。</p>
<p>“长短视频之间并非简单机械的竞争关系，更应是一种共生关系。且在当前大环境下，长短视频抱团合作也能取得不错效果。”浙江大学国际联合商学院数字经济与金融创新研究中心研究员盘和林告诉澎湃新闻记者。</p>
<p>在他看来，腾讯的利益在于通过短视频的二创强化自有视频IP的传播度，从而实现流量增长，提高IP播放量，夯实平台盈利能力，等于免费通过抖音短视频引流。而抖音则保留了二创这一关键的抖音短视频内容模式，为抖音平台上的自媒体争取到更多可以二创的IP内容。</p>
<p>“从商业模式分析，腾讯视频和抖音不是竞争对手。腾讯视频的营收来源依赖会员和广告，而抖音则通过电商和广告盈利，两者的客户重合度并不高。”艾媒咨询CEO张毅告诉澎湃新闻记者，“对于腾讯视频而言，抖音的短视频二创是很好的引流手段和工具。对于抖音而言，和腾讯合作也为创作者提供了更多改编空间。”</p>
]]></content>
      <categories>
        <category>互联网</category>
        <category>新媒体</category>
      </categories>
      <tags>
        <tag>新媒体</tag>
      </tags>
  </entry>
</search>
