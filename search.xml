<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《杀虫》若水</title>
      <link href="/posts/ae350edf"/>
      <url>/posts/ae350edf</url>
      
        <content type="html"><![CDATA[<p>初夏的天气已经使我心烦意乱</p><p>休憩了太久</p><p>思索几番，不得真谛</p><p>一只弱小的虫，趴在闪烁的悬崖处</p><p>试探着，一个无情之人的善念</p><p>是否会给它一个了断</p><p>先是假装的挣扎</p><p>再来几个诱惑性的旋转舞蹈</p><p>绕过睫毛，似乎还有话要说</p><p>絮絮叨叨，总也说不完</p><p>终于——</p><p>食指和拇指不耐烦地捏住了这可怜的虫</p><p>稍一用力</p><p>碾碎了一个有骨气的灵魂</p><p>柔软的翅膀多了几分铁骨铮铮</p><p>一手扔到地上</p><p>闭上眼</p><p>进了梦境</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些很有用的JavaScript代码</title>
      <link href="/posts/bbf49370"/>
      <url>/posts/bbf49370</url>
      
        <content type="html"><![CDATA[<h3 id="获取浏览器cookie值"><a href="#获取浏览器cookie值" class="headerlink" title="获取浏览器cookie值"></a>获取浏览器cookie值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cookie = name =<span class="string">`; <span class="subst">$&#123;<span class="variable language_">document</span>.cookie&#125;</span>`</span>.<span class="title function_">split</span>(<span class="string">`; <span class="subst">$&#123;name&#125;</span>=`</span>).<span class="title function_">pop</span>().<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>).<span class="title function_">shift</span>();</span><br><span class="line"><span class="title function_">cookie</span>(<span class="string">&#x27;_ga&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="将RGB转换为16进制"><a href="#将RGB转换为16进制" class="headerlink" title="将RGB转换为16进制"></a>将RGB转换为16进制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">rgbToHex</span> = (<span class="params">r, g, b</span>) =&gt;</span><br><span class="line"><span class="string">&quot;#&quot;</span> + ((<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + (r &lt;&lt; <span class="number">16</span>) + (g &lt;&lt; <span class="number">8</span>) + b).<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">rgbToHex</span>(<span class="number">0</span>, <span class="number">51</span>, <span class="number">255</span>);</span><br></pre></td></tr></table></figure><h3 id="复制到剪切板"><a href="#复制到剪切板" class="headerlink" title="复制到剪切板"></a>复制到剪切板</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> copyToClipboard = (text) =navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(text);</span><br><span class="line"><span class="title function_">copyToClipboard</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="检查日期是否有效"><a href="#检查日期是否有效" class="headerlink" title="检查日期是否有效"></a>检查日期是否有效</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isDateValid = (...val) =!<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(...val).<span class="title function_">valueOf</span>());</span><br><span class="line"><span class="title function_">isDateValid</span>(<span class="string">&quot;December 17, 1995 03:24:00&quot;</span>);</span><br></pre></td></tr></table></figure><p>找出一年中的某一天（即给出一个日期，程序给出属于本年的第多少天）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dayOfYear</span> = (<span class="params">date</span>) =&gt;</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>((date - <span class="keyword">new</span> <span class="title class_">Date</span>(date.<span class="title function_">getFullYear</span>(), <span class="number">0</span>, <span class="number">0</span>)) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">dayOfYear</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// Result: 272</span></span><br></pre></td></tr></table></figure><h3 id="将字符串首字母大写"><a href="#将字符串首字母大写" class="headerlink" title="将字符串首字母大写"></a>将字符串首字母大写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> capitalize = str =str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">capitalize</span>(<span class="string">&quot;follow for more&quot;</span>)</span><br><span class="line"><span class="comment">// Result: Follow for more</span></span><br></pre></td></tr></table></figure><h3 id="计算两个日期之间相差的天数"><a href="#计算两个日期之间相差的天数" class="headerlink" title="计算两个日期之间相差的天数"></a>计算两个日期之间相差的天数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dayDif = (date1, date2) =<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(date1.<span class="title function_">getTime</span>() - date2.<span class="title function_">getTime</span>()) / <span class="number">86400000</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">dayDif</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2020-10-21&quot;</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2021-10-22&quot;</span>))</span><br><span class="line"><span class="comment">// Result: 366</span></span><br></pre></td></tr></table></figure><h3 id="清除所有cookie"><a href="#清除所有cookie" class="headerlink" title="清除所有cookie"></a>清除所有cookie</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clearCookies = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>).<span class="title function_">forEach</span>(cookie =<span class="variable language_">document</span>.<span class="property">cookie</span> = cookie.<span class="title function_">replace</span>(<span class="regexp">/^ +/</span>, <span class="string">&#x27;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/=.\*/</span>, <span class="string">`=;expires=<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>).toUTCString()&#125;</span>;path=/`</span>));</span><br></pre></td></tr></table></figure><h3 id="生成随机16进制"><a href="#生成随机16进制" class="headerlink" title="生成随机16进制"></a>生成随机16进制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomHex = () =<span class="string">`#<span class="subst">$&#123;<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">0xffffff</span>).toString(<span class="number">16</span>).padEnd(<span class="number">6</span>, <span class="string">&quot;0&quot;</span>)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">randomHex</span>());</span><br><span class="line"><span class="comment">// Result: #92b008</span></span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeDuplicates = (arr) =[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">removeDuplicates</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>]));</span><br><span class="line"><span class="comment">// Result: [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure><h3 id="从URL中获取查询参数"><a href="#从URL中获取查询参数" class="headerlink" title="从URL中获取查询参数"></a>从URL中获取查询参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getParameters = (<span class="variable constant_">URL</span>) =&#123;</span><br><span class="line"><span class="variable constant_">URL</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;&#x27;</span> + <span class="built_in">decodeURI</span>(<span class="variable constant_">URL</span>.<span class="title function_">split</span>(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>]).<span class="title function_">replace</span>(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;\\&quot;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&quot;,&quot;&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/=/g</span>, <span class="string">&#x27;&quot;:&quot;&#x27;</span>) +<span class="string">&#x27;&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable constant_">URL</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getParameters</span>(<span class="variable language_">window</span>.<span class="property">location</span>)</span><br><span class="line"><span class="comment">// Result: &#123; search : &quot;easy&quot;, page : 3 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="从日期中获取“时分秒”格式的时间"><a href="#从日期中获取“时分秒”格式的时间" class="headerlink" title="从日期中获取“时分秒”格式的时间"></a>从日期中获取“时分秒”格式的时间</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeFromDate = date =date.<span class="title function_">toTimeString</span>().<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">timeFromDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2021</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">30</span>, <span class="number">0</span>)));</span><br><span class="line"><span class="comment">// Result: &quot;17:30:00&quot;</span></span><br></pre></td></tr></table></figure><h3 id="确认奇偶数"><a href="#确认奇偶数" class="headerlink" title="确认奇偶数"></a>确认奇偶数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过数据%2来判断并返回布尔类型</span></span><br><span class="line"><span class="keyword">const</span> isEven = num =num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEven</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// Result: True</span></span><br></pre></td></tr></table></figure><h3 id="回到顶部（适用于网页右下角快捷返回功能）"><a href="#回到顶部（适用于网页右下角快捷返回功能）" class="headerlink" title="回到顶部（适用于网页右下角快捷返回功能）"></a>回到顶部（适用于网页右下角快捷返回功能）</h3><p>//通过将x、y设置为0来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> goToTop = () =<span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="title function_">goToTop</span>();</span><br></pre></td></tr></table></figure><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverse = str =str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="title function_">reverse</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="comment">// Result: &#x27;dlrow olleh&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="检查数组是否为空"><a href="#检查数组是否为空" class="headerlink" title="检查数组是否为空"></a>检查数组是否为空</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过对数组长度判断来确定是否为空</span></span><br><span class="line"><span class="keyword">const</span> isNotEmpty = arr =<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) &amp;&amp; arr.<span class="property">length</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isNotEmpty</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// Result: true</span></span><br></pre></td></tr></table></figure><h3 id="获取用户选定的文本"><a href="#获取用户选定的文本" class="headerlink" title="获取用户选定的文本"></a>获取用户选定的文本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getSelectedText = () =<span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSelectedText</span>();</span><br></pre></td></tr></table></figure><h3 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a>打乱数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shuffleArray = (arr) =arr.<span class="title function_">sort</span>(() =<span class="number">0.5</span> - <span class="title class_">Math</span>.<span class="title function_">random</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">shuffleArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br><span class="line"><span class="comment">// Result: [ 1, 4, 3, 2 ]</span></span><br></pre></td></tr></table></figure><h3 id="检查用户是否处于暗模式"><a href="#检查用户是否处于暗模式" class="headerlink" title="检查用户是否处于暗模式"></a>检查用户是否处于暗模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isDarkMode = <span class="variable language_">window</span>.<span class="property">matchMedia</span> &amp;&amp; <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(prefers-color-scheme: dark)&#x27;</span>).<span class="property">matches</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isDarkMode) <span class="comment">// Result: True or False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的npm依赖环境以及博客部署备忘录</title>
      <link href="/posts/28dcdc4c"/>
      <url>/posts/28dcdc4c</url>
      
        <content type="html"><![CDATA[<h3 id="pug-以及-stylus-的渲染器"><a href="#pug-以及-stylus-的渲染器" class="headerlink" title="pug 以及 stylus 的渲染器"></a>pug 以及 stylus 的渲染器</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer-pug</span> hexo<span class="literal">-renderer-stylus</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><h3 id="butterfly开启本地搜索"><a href="#butterfly开启本地搜索" class="headerlink" title="butterfly开启本地搜索"></a>butterfly开启本地搜索</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-generator-search</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><h3 id="开启hexo-abbrlink文章链接"><a href="#开启hexo-abbrlink文章链接" class="headerlink" title="开启hexo-abbrlink文章链接"></a>开启hexo-abbrlink文章链接</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-abbrlink</span> <span class="literal">--save</span> </span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span>     <span class="comment"># 将原来文章的地址修改为这个</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 并添加如下配置：</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment">#support dec(default) and hex</span></span><br><span class="line">  <span class="attr">drafts:</span> <span class="literal">false</span>   <span class="comment">#(true)Process draft,(false)Do not process draft. false(default) </span></span><br></pre></td></tr></table></figure><h3 id="部署必备插件"><a href="#部署必备插件" class="headerlink" title="部署必备插件"></a>部署必备插件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-deployer-git</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><h3 id="开启百度站长主动推送文章链接"><a href="#开启百度站长主动推送文章链接" class="headerlink" title="开启百度站长主动推送文章链接"></a>开启百度站长主动推送文章链接</h3><p>安装依赖</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-baidu-url-submit</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><p>修改配置文件<code>_config.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置百度主动推送</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">200</span>  <span class="comment">#比如200，代表提交最新的200个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">www.kimtoli.com</span> <span class="comment"># 在百度站长平台中注册的域名，这个改为你自己的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">your_token</span> <span class="comment"># 百度站长token字段</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 新链接会保存在此文本文档里（文本文件的文件名）</span></span><br></pre></td></tr></table></figure><p>加入新的deploy项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:XXX/XXX.github.io.git</span>  <span class="comment"># Github地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span>  <span class="comment"># 这一行是新增的配置</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go中netpoll的工作机制</title>
      <link href="/posts/794f771b"/>
      <url>/posts/794f771b</url>
      
        <content type="html"><![CDATA[<h2 id="netpollGenericInit-初始化-poller"><a href="#netpollGenericInit-初始化-poller" class="headerlink" title="netpollGenericInit 初始化 poller"></a>netpollGenericInit 初始化 poller</h2><p>netpollGenericInit 保证 poller 被初始化，原子变量netpollInited保证其仅被初始化一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollGenericInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.Load(&amp;netpollInited) == <span class="number">0</span> &#123;</span><br><span class="line">    lockInit(&amp;netpollInitLock, lockRankNetpollInit)</span><br><span class="line">    lock(&amp;netpollInitLock)</span><br><span class="line">    <span class="keyword">if</span> netpollInited == <span class="number">0</span> &#123;</span><br><span class="line">      netpollinit()</span><br><span class="line">      atomic.Store(&amp;netpollInited, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;netpollInitLock)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数只是一个壳，初始化逻辑封装在netpollinit函数中，依赖于平台具体的实现。linux下，init的逻辑是:</p><ol><li>通过epoll_create1系统调用创建 epoll fd</li><li>创建一对 read/write pipe。pipe的一个特性是向 write pipe写入数据，read pipe 就能收到同样的数据</li><li>通过epoll_ctl将 write pipe 对应的fd 加入到监听列表</li></ol><p>单独创建一对pipe后，runtime就能够按需中断epoll_wait，让netpoll函数立即返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">  <span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">    epfd = epollcreate(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: epollcreate failed with&quot;</span>, -epfd)</span><br><span class="line">      throw(<span class="string">&quot;runtime: netpollinit failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    closeonexec(epfd)</span><br><span class="line">  &#125;</span><br><span class="line">  r, w, errno := nonblockingPipe()</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;runtime: pipe failed with&quot;</span>, -errno)</span><br><span class="line">    throw(<span class="string">&quot;runtime: pipe failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ev := epollevent&#123;</span><br><span class="line">    events: _EPOLLIN,</span><br><span class="line">  &#125;</span><br><span class="line">  *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd</span><br><span class="line">  errno = epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;runtime: epollctl failed with&quot;</span>, -errno)</span><br><span class="line">    throw(<span class="string">&quot;runtime: epollctl failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  netpollBreakRd = <span class="type">uintptr</span>(r)</span><br><span class="line">  netpollBreakWr = <span class="type">uintptr</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="netpoll函数"><a href="#netpoll函数" class="headerlink" title="netpoll函数"></a>netpoll函数</h2><p>netpoll函数的功能是检查可用的网络连接，它的工作流程是(happy path)：</p><ol><li><p>创建size=128的epollevent数组, 以接收事件</p></li><li><p>调用epollwait等待事件: 依赖epoll_wait系统调用</p></li><li><p>遍历epoll events，对于每个event</p></li><li><ul><li>创建一个pollDesc对象</li><li>调用netpollready，找到对应的goroutine，并将其状态从pdWait修改为pdReady</li></ul></li><li><p>返回pdReady状态的 goroutine列表 (gList)</p></li></ol><p>struct pollDesc中包含两个信号量字段，可以表示四种状态:</p><ol><li><p>pdReady: io ready信号等待被接收，goroutine可以消费这个信号，逻辑上是把信号量改成nil</p></li><li><p>pdWait: goroutine已经准备好在该信号量上阻塞，但还没有阻塞；</p></li><li><ul><li>如果goroutine通过gopark阻塞，状态会变成G pointer</li><li>如果并发的io ready信号到达，状态会改成pdReady</li><li>如果并发的timeout/close信号到达，状态会被改成nil</li></ul></li><li><p>G pointer: goroutine被阻塞在信号量上，可以被下面两类事件唤醒:</p></li><li><ul><li>io ready信号到来时，状态被修改好pdReady</li><li>timeout/close信号到来时，状态被修改为nil</li></ul></li><li><p>nil: 不是上面三种状态</p></li></ol><p>对应一些辅助函数:</p><ul><li>netpollblock 函数将goroutine状态从 pdReady 转化成 pdWait，并gopark当前goroutine</li><li>netpollunblock 函数将goroutine状态从 pdWait 转换为 pdReady 或 nil</li></ul><p>netpoll函数的代码在runtime/netpoll_epoll.go中，部分代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="type">int64</span>)</span></span> gList &#123;</span><br><span class="line">  <span class="comment">// epoll fd 为-1，说明不需要poll</span></span><br><span class="line">  <span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> waitms <span class="type">int32</span></span><br><span class="line">  <span class="comment">// ...省略一段代码</span></span><br><span class="line">  <span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">  n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="type">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">  <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n != -_EINTR &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: epollwait on fd&quot;</span>, epfd, <span class="string">&quot;failed with&quot;</span>, -n)</span><br><span class="line">      throw(<span class="string">&quot;runtime: netpoll failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If a timed sleep was interrupted, just return to</span></span><br><span class="line">    <span class="comment">// recalculate how long we should sleep now.</span></span><br><span class="line">    <span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> retry</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> toRun gList</span><br><span class="line">  <span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">    ev := &amp;events[i]</span><br><span class="line">    <span class="keyword">if</span> ev.events == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> *(**<span class="type">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">      <span class="comment">// ... read pipe 有数据</span></span><br><span class="line">      <span class="comment">// 不需要唤醒任何goroutine</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mode <span class="type">int32</span></span><br><span class="line">    <span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">      mode += <span class="string">&#x27;r&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">      mode += <span class="string">&#x27;w&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">      pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">      pd.setEventErr(ev.events == _EPOLLERR)</span><br><span class="line">      <span class="comment">// 将goroutine置为 pdReady</span></span><br><span class="line">      <span class="comment">// 并添加到toRun *gList</span></span><br><span class="line">      netpollready(&amp;toRun, pd, mode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toRun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注: netpollready 函数借助于netpollunblock修改goroutine状态，并将其加到 io ready 的 goroutine list。</p><p>runtime在调用 netpoll 时，通常采用的是 nonblock 模式(delay=0), 只有在 findrunnable 的最后一个环节，会检查是否有单独的M(GMP中的M)进行net polling，如果没有，会block等待delay参数指定的时间。</p><h2 id="netpollBreak-函数"><a href="#netpollBreak-函数" class="headerlink" title="netpollBreak 函数"></a>netpollBreak 函数</h2><p>netpollBreak函数的功能比较简单，但实现比较有意思。它和netpoll函数通过变量netpollWakeSig进行交互，由于在不同的goroutine中，所以对于该变量的操作都是原则操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netpollBreak interrupts an epollwait.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollBreak</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.Cas(&amp;netpollWakeSig, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> b <span class="type">byte</span></span><br><span class="line">      n := write(netpollBreakWr, unsafe.Pointer(&amp;b), <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> n == -_EINTR &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> n == -_EAGAIN &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;runtime: netpollBreak write failed with&quot;</span>, -n)</span><br><span class="line">      throw(<span class="string">&quot;runtime: netpollBreak write failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll-runtime-pollOpen-函数"><a href="#poll-runtime-pollOpen-函数" class="headerlink" title="poll_runtime_pollOpen 函数"></a>poll_runtime_pollOpen 函数</h2><p>poll_runtime_pollOpen 的逻辑分为三块:</p><ol><li>给 pollDesc 分配内存</li><li>初始化 pollDesc 对象</li><li>借助于 netpollopen 注册epoll监听(netpollopen在linux下是 epoll_ctl)</li><li>返回 pollDesc 对象</li></ol><p>poll_runtime_pollOpen函数的实现位于 runtime/netpoll.go 中, 主要逻辑如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="type">uintptr</span>)</span></span> (*pollDesc, <span class="type">int</span>) &#123;</span><br><span class="line">  pd := pollcache.alloc()</span><br><span class="line">  lock(&amp;pd.lock)</span><br><span class="line">  wg := pd.wg.Load()</span><br><span class="line">  <span class="keyword">if</span> wg != <span class="number">0</span> &amp;&amp; wg != pdReady &#123;</span><br><span class="line">    throw(<span class="string">&quot;runtime: blocked write on free polldesc&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  rg := pd.rg.Load()</span><br><span class="line">  <span class="keyword">if</span> rg != <span class="number">0</span> &amp;&amp; rg != pdReady &#123;</span><br><span class="line">    throw(<span class="string">&quot;runtime: blocked read on free polldesc&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  pd.fd = fd</span><br><span class="line">  <span class="comment">// ... 省略部分初始化逻辑</span></span><br><span class="line">  unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">  errno := netpollopen(fd, pd)</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    pollcache.free(pd)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="type">int</span>(errno)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pd, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于net/netpoll_epoll.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="type">uintptr</span>, pd *pollDesc)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> ev epollevent</span><br><span class="line">  ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">  *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">  <span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="type">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll-runtime-pollWait-函数"><a href="#poll-runtime-pollWait-函数" class="headerlink" title="poll_runtime_pollWait 函数"></a>poll_runtime_pollWait 函数</h2><p>poll_runtime_pollWait 函数只是对 netpollblock 函数的封装，增加了容错。值得注意的是，该函数不是runtime触发的，而是用户程序触发的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  errcode := netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">  <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">    <span class="keyword">return</span> errcode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// As for now only Solaris, illumos, and AIX use level-triggered IO.</span></span><br><span class="line">  <span class="keyword">if</span> GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;aix&quot;</span> &#123;</span><br><span class="line">    netpollarm(pd, mode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> !netpollblock(pd, <span class="type">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">    errcode = netpollcheckerr(pd, <span class="type">int32</span>(mode))</span><br><span class="line">    <span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">      <span class="keyword">return</span> errcode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Can happen if timeout has fired and unblocked us,</span></span><br><span class="line">    <span class="comment">// but before we had a chance to run, timeout has been reset.</span></span><br><span class="line">    <span class="comment">// Pretend it has not happened and retry.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们看下用户程序如何触发 poll_runtime_xxx 系列的函数。首先，套接字分为两类：LISTEN套接字(Server套接字) 和 ESTABLISHED套接字(TCPConn)；</p><ul><li>LISTEN 套接字通过系统调用 socket/bind/listen 去生成；</li><li>ESTABLISHED 套接字通过系统调用 accept 去生成；</li></ul><h2 id="LISTEN套接字-Server套接字"><a href="#LISTEN套接字-Server套接字" class="headerlink" title="LISTEN套接字(Server套接字)"></a>LISTEN套接字(Server套接字)</h2><p>从http server的角度来看，LISTEN套接字注册epoll监听的链路如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> ListenAndServe() <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// net/dial.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="type">string</span>)</span></span> (Listener, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> lc ListenConfig</span><br><span class="line">  <span class="keyword">return</span> lc.Listen(context.Background(), network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/dial.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lc *ListenConfig)</span></span> Listen(ctx context.Context, network, address <span class="type">string</span>) (Listener, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/tcpsock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sysListener)</span></span> listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/ipsock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internetSocket</span><span class="params">(ctx context.Context, net <span class="type">string</span>, laddr, raddr sockaddr, sotype, proto <span class="type">int</span>, mode <span class="type">string</span>, ctrlFn <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>, syscall.RawConn)</span></span> <span class="type">error</span>) (fd *netFD, err <span class="type">error</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// net/sock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="type">string</span>, family, sotype, proto <span class="type">int</span>, ipv6only <span class="type">bool</span>, laddr, raddr sockaddr, ctrlFn <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>, syscall.RawConn)</span></span> <span class="type">error</span>) (fd *netFD, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/sock_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> listenStream(laddr sockaddr, backlog <span class="type">int</span>, ctrlFn <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, <span class="type">string</span>, syscall.RawConn)</span></span> <span class="type">error</span>)</span><br><span class="line">  <span class="keyword">if</span> err = fd.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> init() <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// fd.pfd 类型是 poll.FD</span></span><br><span class="line">  <span class="keyword">return</span> fd.pfd.Init(fd.net, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Init(net <span class="type">string</span>, pollable <span class="type">bool</span>) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// We don&#x27;t actually care about the various network types.</span></span><br><span class="line">  <span class="keyword">if</span> net == <span class="string">&quot;file&quot;</span> &#123;</span><br><span class="line">    fd.isFile = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> !pollable &#123;</span><br><span class="line">    fd.isBlocking = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  err := fd.pd.init(fd)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// If we could not initialize the runtime poller,</span></span><br><span class="line">    <span class="comment">// assume we are using blocking mode.</span></span><br><span class="line">    fd.isBlocking = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_poll_runtime.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">  serverInit.Do(runtime_pollServerInit)</span><br><span class="line">  ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">  &#125;</span><br><span class="line">  pd.runtimeCtx = ctx</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ESTABLISHED套接字-TCPConn"><a href="#ESTABLISHED套接字-TCPConn" class="headerlink" title="ESTABLISHED套接字(TCPConn)"></a>ESTABLISHED套接字(TCPConn)</h2><p>http server accept 新的tcp conn</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    rw, err := l.Accept()</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/tcpsock.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *TCPListener)</span></span> Accept() (Conn, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ln *TCPListener)</span></span> accept() (*TCPConn, <span class="type">error</span>) &#123;</span><br><span class="line">  fd, err := ln.fd.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment">// net/fd_posix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> accept() (netfd *netFD, err <span class="type">error</span>) &#123;</span><br><span class="line">  d, rsa, errcall, err := fd.pfd.Accept()</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  <span class="keyword">if</span> err = netfd.init(); err != <span class="literal">nil</span></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_unix.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span></span> Init(net <span class="type">string</span>, pollable <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal/poll/fd_poll_runtime.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span></span><br></pre></td></tr></table></figure><h2 id="关于-net-netFD-struct"><a href="#关于-net-netFD-struct" class="headerlink" title="关于 net.netFD struct"></a>关于 net.netFD struct</h2><p>netFD是对套接字(网络文件描述符)的封装。对于Server套接字而言，可以通过accept方法从Server套接字(LISTEN套接字)获取新的TCP连接(或ESTABLISHED套接字)。Linux的accept系统调用返回的ESTABLISHED套接字是一个int值，通过 newFD 和 init 函数将其封装为一个完整的 netFD结构，后面会被封装为一个net.TCPConn。</p><p>对于操作系统而言，LISTEN套接字和ESTABLISHED套接字都只是一个int类型的文件描述符，没有本质区别。系统调用accept和read都是从套接字读取数据，所以epoll里会放到一个batch里去监听。</p><p>这是 netFD 的定义和accept方法的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network file descriptor.</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">  pfd poll.FD</span><br><span class="line"></span><br><span class="line">  <span class="comment">// immutable until Close</span></span><br><span class="line">  family      <span class="type">int</span></span><br><span class="line">  sotype      <span class="type">int</span></span><br><span class="line">  isConnected <span class="type">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">  net         <span class="type">string</span></span><br><span class="line">  laddr       Addr</span><br><span class="line">  raddr       Addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span></span> accept() (netfd *netFD, err <span class="type">error</span>) &#123;</span><br><span class="line">  d, rsa, errcall, err := fd.pfd.Accept()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> errcall != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      err = wrapSyscallError(errcall, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    poll.CloseFunc(d)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err = netfd.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    netfd.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  lsa, _ := syscall.Getsockname(netfd.pfd.Sysfd)</span><br><span class="line">  netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))</span><br><span class="line">  <span class="keyword">return</span> netfd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>net.netFD 依赖 poll.FD 实现poll功能。区别正如名字所展示，net.netFD是封装了网络相关的功能，而 poll.FD是更为通用的FD，封装了文件描述符上能进行的操作。其定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FD is a file descriptor. The net and os packages use this type as a</span></span><br><span class="line"><span class="comment">// field of a larger type representing a network connection or OS file.</span></span><br><span class="line"><span class="keyword">type</span> FD <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// Lock sysfd and serialize access to Read and Write methods.</span></span><br><span class="line">  fdmu fdMutex</span><br><span class="line"></span><br><span class="line">  <span class="comment">// System file descriptor. Immutable until Close.</span></span><br><span class="line">  Sysfd <span class="type">int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// I/O poller.</span></span><br><span class="line">  pd pollDesc</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Writev cache.</span></span><br><span class="line">  iovecs *[]syscall.Iovec</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Semaphore signaled when file is closed.</span></span><br><span class="line">  csema <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Non-zero if this file has been set to blocking mode.</span></span><br><span class="line">  isBlocking <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether this is a streaming descriptor, as opposed to a</span></span><br><span class="line">  <span class="comment">// packet-based descriptor like a UDP socket. Immutable.</span></span><br><span class="line">  IsStream <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether a zero byte read indicates EOF. This is false for a</span></span><br><span class="line">  <span class="comment">// message based socket connection.</span></span><br><span class="line">  ZeroReadIsEOF <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether this is a file rather than a network socket.</span></span><br><span class="line">  isFile <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poll.FD 依赖 poll.pollDesc 实现poll功能。poll.pollDesc 实现了 IO polling 的功能。poll.pollDesc 有一系列的方法，比如 init、wait、close、prepare 等都是对 runtime_pollXXX 函数系列的封装，下面诗pollDesc的部分逻辑:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">  runtimeCtx <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverInit sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span></span> init(fd *FD) <span class="type">error</span> &#123;</span><br><span class="line">  serverInit.Do(runtime_pollServerInit)</span><br><span class="line">  ctx, errno := runtime_pollOpen(<span class="type">uintptr</span>(fd.Sysfd))</span><br><span class="line">  <span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">  &#125;</span><br><span class="line">  pd.runtimeCtx = ctx</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术类 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。</title>
      <link href="/posts/fcce4138"/>
      <url>/posts/fcce4138</url>
      
        <content type="html"><![CDATA[<h3 id="腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。"><a href="#腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。" class="headerlink" title="腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。"></a>腾讯和字节这对曾经的冤家，在视频二创上竟然上演了世纪大和解。</h3><p>4月7日，腾讯视频与抖音集团宣布达成合作，双方将围绕长短视频联动推广、短视频衍生创作开展合作。腾讯视频将向抖音授权其享有信息网络传播权及转授权权利的长视频。此外，腾讯视频与抖音还明确了短视频衍生创作的方式、发布规则，共同促进短视频的创作、传播。</p><p>这次合作，也被外界视为“世纪大和解”。此前，腾讯和抖音曾因版权问题多次对簿公堂，也曾在公开场合互相炮轰。如今双方的握手言和，意味着双方在长短视频创作领域找到了利益共通点。在短视频的直接交锋之外，腾讯的长视频资源也可以以版权授权的形式，授予它的直接竞争对手。</p><p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102130.jpg" alt="腾讯和抖音合作"></p><h3 id="腾讯自营短视频产品的始末"><a href="#腾讯自营短视频产品的始末" class="headerlink" title="腾讯自营短视频产品的始末"></a>腾讯自营短视频产品的始末</h3><p>值得一提的是，腾讯其实是国内最早布局短视频的互联网公司之一，早在2013年，就上线了微视，但当时的战略，不过是对标海外产品的进行新产品尝试，并没有在战略上重视，由于总办对其市场化的误判，最后在2015年开始实质上放弃。</p><p>快手和抖音火爆后，腾讯希望重新回到这条赛道上来，这几年，腾讯帝国内部各路诸侯先后发布了哈皮、yoo视频等十余款短视频APP，最后基本都以失败告终。</p><p>2017年，以抖音和快手为代表的短视频持续高歌猛进，腾讯开始复活微视，甚至提到了“战略级”。但微视这款产品似乎受到了诅咒，内部资源和组织难以顺畅打通，发力艰难，在外部，则一直不被主流圈子看好，现在依然处在艰难爬坡的状态，目前看只能作为防御性产品拖住竞争对手。</p><p>也是在这个时候，腾讯微视的小2联系到了我，顺利入住的微视MCN合作机构，作为集团“战略级”产品，扶持当然是不能少了，腾讯集团公司花了巨款砸在了内容补贴上面，补贴方式为cpm结算，实不相瞒。。我在刚开始做的时候，最风口的时刻，单微视这一个项目单月拿了60多个W的流水（包含达人50%的分成，以及将近4万块的增值税），流水月入百万的MCN机构老板我微信朋友圈也加着几个，只能说腾讯在力度方面真的狠上了。。。。</p><p>但是，投入巨大资源的微视在2019年并没有完成4000万DAU的目标，从腾讯PCG负责人任宇昕在年会上定2020年新目标为5000万DAU的目标来看，2019年的目标是远远未达标的。当然，微视最大的问题，不是缺增长，而是缺留存，快手与抖音的留存都在80%左右，而微视仅在43%上下徘徊，这就非常尴尬。在2020年，它大概率会被认定为一款只有防守价值的产品。</p><p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102045.jpg" alt="腾讯微视"></p><h3 id="曾多次对簿公堂，创始人曾朋友圈“互怼”"><a href="#曾多次对簿公堂，创始人曾朋友圈“互怼”" class="headerlink" title="曾多次对簿公堂，创始人曾朋友圈“互怼”"></a><strong>曾多次对簿公堂，创始人曾朋友圈“互怼”</strong></h3><p>2018年5月，抖音成为全球第一季度App Store下载量最高应用时，字节跳动创始人张一鸣在朋友圈写下这样一句话，“微信的借口封杀，微视的抄袭搬运，挡不住抖音的步伐。”腾讯创始人马化腾随即在下方回应称：“可以理解为诽谤。”</p><p>两名互联网大佬朋友圈公开互怼背后，是腾讯和字节之间“头腾大战”持续升级的一个缩影。特别是在短视频领域，当时占据杆位的抖音，对迟迟未能形成突破的腾讯，形成巨大压力。版权，成了双方交锋的一个发泄口。</p><p>公开资料显示，腾讯和抖音之间就视频版权有过多次纠纷。去年10月26日，西安市中级人民法院就《云南虫谷》案作出一审判决。法院认为，抖音平台上有大量用户对涉案作品实施侵权行为，需赔偿腾讯经济损失及合理费用3240余万元，刷新了全国法院网络影视版权案件赔偿纪录。</p><p>公开资料显示，《云南虫谷》为腾讯旗下企鹅影视出品的悬疑冒险网络剧，改编自天下霸唱小说《鬼吹灯之云南虫谷》。</p><p>2021年6月，腾讯向重庆一中院起诉，认为抖音平台内的用户上传内容侵害了《斗罗大陆》著作权，要求法院判令抖音赔偿经济损失并合理支出共计6160万元，此后又将索赔金额从6160万元提高到8亿元。</p><p>同年，字节跳动也在重庆市第一中级法院起诉腾讯，原因是腾讯视频上存在大量涉及电视剧《亮剑》的侵权视频，要求法院判令腾讯删除侵权视频、发布声明消除影响，并赔偿经济损失1000万元。</p><p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102155.jpg" alt="腾讯VS抖音"></p><h3 id="视频号和抖音的产品整合？"><a href="#视频号和抖音的产品整合？" class="headerlink" title="视频号和抖音的产品整合？"></a><strong>视频号和抖音的产品整合？</strong></h3><p>微信视频号的崛起，应该也为腾讯视频对外版权合作提供了更多底气。</p><p>眼下，视频号已成微信业务中当之无愧的“C位”。据腾讯最新财报，微信视频号的使用时长已达到朋友圈的1.2倍。数据显示，去年第四季度，视频号季度收入超过10亿，去年视频号直播带货销售增长800%，累计有收入的作者数对比2021年增长2.64倍。</p><p>腾讯CEO马化腾也曾在内部员工大会上的讲话中提到，微信事业群最亮眼的业务是视频号，基本上是全公司的希望。</p><p>不过，腾讯高管也在财报后的电话会议中坦言，相比竞争对手的短视频服务，视频号目前的广告数量仍处于相对落后的水平。相比抖音，腾讯视频号也尚未孵化出头部创作者。</p><p><img src="https://cdn.kimtoli.com/Blog/post_img/20230408102213.jpg" alt="视频号"></p><h3 id="长短视频平台大和解"><a href="#长短视频平台大和解" class="headerlink" title="长短视频平台大和解"></a><strong>长短视频平台大和解</strong></h3><p>可见的是，这并不是长短视频平台的首次牵手。去年7月19日，抖音集团和爱奇艺宣布达成合作。爱奇艺将向抖音集团授权其内容资产中拥有信息网络传播权及转授权的长视频内容，用于短视频创作，双方也对解说、混剪、拆条等短视频二创形态做出具体约定。</p><p>去年6月30日，快手曾宣布与乐视视频达成二创相关授权合作。这意味着快手创作者可以对乐视视频独家自制版权作品进行剪辑及二次创作，并发布在快手平台内。</p><p>“长短视频之间并非简单机械的竞争关系，更应是一种共生关系。且在当前大环境下，长短视频抱团合作也能取得不错效果。”浙江大学国际联合商学院数字经济与金融创新研究中心研究员盘和林告诉澎湃新闻记者。</p><p>在他看来，腾讯的利益在于通过短视频的二创强化自有视频IP的传播度，从而实现流量增长，提高IP播放量，夯实平台盈利能力，等于免费通过抖音短视频引流。而抖音则保留了二创这一关键的抖音短视频内容模式，为抖音平台上的自媒体争取到更多可以二创的IP内容。</p><p>“从商业模式分析，腾讯视频和抖音不是竞争对手。腾讯视频的营收来源依赖会员和广告，而抖音则通过电商和广告盈利，两者的客户重合度并不高。”艾媒咨询CEO张毅告诉澎湃新闻记者，“对于腾讯视频而言，抖音的短视频二创是很好的引流手段和工具。对于抖音而言，和腾讯合作也为创作者提供了更多改编空间。”</p>]]></content>
      
      
      <categories>
          
          <category> 互联网 </category>
          
          <category> 新媒体 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新媒体 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
